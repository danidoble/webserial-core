{"version":3,"file":"webserial-core.js","sources":["../lib/SerialEvent.ts","../lib/Dispatcher.ts","../lib/Devices.ts","../lib/utils.ts","../lib/Socket.ts","../lib/Core.ts","../lib/SerialError.ts"],"sourcesContent":["export class SerialEvent extends CustomEvent<SerialEvent> implements CustomEvent {\n  constructor(type: string, options: CustomEventInit) {\n    super(type, options);\n  }\n}\n","import { SerialEvent } from \"./SerialEvent\";\n\ntype AvailableListener = { type: string; listening: boolean };\ntype AvailableListeners = AvailableListener[];\n\ntype DataType = string | number | boolean | object | null;\n\ninterface IDispatcher {\n  dispatch(type: string, data?: DataType): void;\n\n  dispatchAsync(type: string, data?: DataType, ms?: number): void;\n\n  on(type: string, callback: EventListener): void;\n\n  off(type: string, callback: EventListener): void;\n\n  serialRegisterAvailableListener(type: string): void;\n\n  availableListeners: AvailableListeners;\n}\n\ninterface Listeners {\n  [key: string]: boolean;\n\n  debug: boolean;\n}\n\nexport class Dispatcher extends EventTarget implements IDispatcher {\n  __listeners__: Listeners = {\n    debug: false,\n  };\n  __debug__: boolean = false;\n\n  __listenersCallbacks__: { key: string; callback: EventListenerOrEventListenerObject }[] = [];\n\n  /**\n   * Dispatches an event with the specified type and data\n   * @param type - The event type to dispatch\n   * @param data - Optional data to attach to the event\n   * @example\n   * ```typescript\n   * dispatcher.dispatch('connected', { port: 'COM3' });\n   * ```\n   */\n  public dispatch(type: string, data: DataType = null) {\n    const event = new SerialEvent(type, { detail: data });\n    this.dispatchEvent(event);\n    if (this.__debug__) {\n      this.dispatchEvent(new SerialEvent(\"debug\", { detail: { type, data } }));\n    }\n  }\n\n  /**\n   * Dispatches an event asynchronously after a specified delay\n   * @param type - The event type to dispatch\n   * @param data - Optional data to attach to the event\n   * @param ms - Delay in milliseconds (default: 100)\n   * @example\n   * ```typescript\n   * dispatcher.dispatchAsync('timeout', { reason: 'no response' }, 500);\n   * ```\n   */\n  public dispatchAsync(type: string, data = null, ms = 100) {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const this1 = this;\n    setTimeout(() => {\n      this1.dispatch(type, data);\n    }, ms);\n  }\n\n  /**\n   * Registers an event listener for the specified event type\n   * @param type - The event type to listen to\n   * @param callback - The callback function to execute when the event is triggered\n   * @example\n   * ```typescript\n   * dispatcher.on('connected', (event) => {\n   *   console.log('Device connected', event.detail);\n   * });\n   * ```\n   */\n  public on(type: string, callback: EventListenerOrEventListenerObject) {\n    if (typeof this.__listeners__[type] !== \"undefined\" && !this.__listeners__[type]) {\n      this.__listeners__[type] = true;\n    }\n\n    this.__listenersCallbacks__.push({ key: type, callback });\n    this.addEventListener(type, callback);\n  }\n\n  /**\n   * Removes an event listener for the specified event type\n   * @param type - The event type to stop listening to\n   * @param callback - The callback function to remove\n   * @example\n   * ```typescript\n   * const handler = (event) => console.log(event.detail);\n   * dispatcher.on('data', handler);\n   * dispatcher.off('data', handler);\n   * ```\n   */\n  public off(type: string, callback: EventListenerOrEventListenerObject) {\n    this.__listenersCallbacks__ = this.__listenersCallbacks__.filter((listener) => {\n      return !(listener.key === type && listener.callback === callback);\n    });\n\n    this.removeEventListener(type, callback);\n  }\n\n  /**\n   * Registers an available listener type for tracking\n   * @param type - The event type to register\n   * @internal\n   */\n  public serialRegisterAvailableListener(type: string) {\n    if (this.__listeners__[type]) return;\n\n    this.__listeners__[type] = false;\n  }\n\n  /**\n   * Gets the list of all available listeners and their state\n   * @returns Array of listener objects with type and listening status\n   * @example\n   * ```typescript\n   * const listeners = dispatcher.availableListeners;\n   * console.log(listeners); // [{ type: 'connected', listening: true }, ...]\n   * ```\n   */\n  get availableListeners(): AvailableListeners {\n    const keys = Object.keys(this.__listeners__).sort();\n    return keys.map((type): AvailableListener => {\n      return {\n        type,\n        listening: this.__listeners__[type],\n      };\n    });\n  }\n\n  /**\n   * Removes all event listeners except internal ones (like queue listeners)\n   * Resets all listener states to false\n   * @example\n   * ```typescript\n   * dispatcher.removeAllListeners();\n   * ```\n   */\n  public removeAllListeners(): void {\n    for (const listener of this.__listenersCallbacks__) {\n      if ([\"internal:queue\"].includes(listener.key)) continue; // Skip queue listener\n\n      this.__listenersCallbacks__ = this.__listenersCallbacks__.filter((l) => {\n        return !(l.key === listener.key && l.callback === listener.callback);\n      });\n      this.removeEventListener(listener.key, listener.callback);\n    }\n    for (const key of Object.keys(this.__listeners__)) {\n      this.__listeners__[key] = false;\n    }\n  }\n}\n","import { Core } from \"./Core\";\nimport { Dispatcher } from \"./Dispatcher\";\n\ninterface IDevice {\n  [key: string]: Core;\n}\n\ninterface IDevices {\n  [key: string]: IDevice;\n}\n\n/**\n * Manages and tracks all serial devices in the application\n * Provides a centralized registry for device instances\n * @extends Dispatcher\n */\nexport class Devices extends Dispatcher {\n  static instance: Devices;\n  static devices: IDevices = {};\n\n  constructor() {\n    super();\n\n    const availableListeners: string[] = [\"change\"];\n\n    availableListeners.forEach((event: string): void => {\n      this.serialRegisterAvailableListener(event);\n    });\n  }\n\n  public static $dispatchChange(device: Core | null = null): void {\n    if (device) {\n      device.$checkAndDispatchConnection();\n    }\n    Devices.instance.dispatch(\"change\", { devices: Devices.devices, dispatcher: device });\n  }\n\n  public static typeError(type: string): void {\n    const error = new Error();\n    error.message = `Type ${type} is not supported`;\n    error.name = \"DeviceTypeError\";\n    throw error;\n  }\n\n  /**\n   * Registers a new device type in the registry\n   * @param type - The type name of the device (e.g., 'arduino', 'esp32')\n   * @internal\n   */\n  public static registerType(type: string): void {\n    if (typeof Devices.devices[type] === \"undefined\") {\n      Devices.devices = { ...Devices.devices, [type]: {} };\n    }\n  }\n\n  /**\n   * Adds a device to the registry\n   * @param device - The Core device instance to add\n   * @returns The index of the device in its type registry\n   * @throws {Error} If device with the same ID already exists\n   * @example\n   * ```typescript\n   * const arduino = new Arduino();\n   * Devices.add(arduino);\n   * ```\n   */\n  public static add(device: Core): number {\n    const type = device.typeDevice;\n    if (typeof Devices.devices[type] === \"undefined\") {\n      Devices.registerType(type);\n    }\n\n    const id: string = device.uuid;\n\n    if (typeof Devices.devices[type] === \"undefined\") Devices.typeError(type);\n\n    if (Devices.devices[type][id]) {\n      throw new Error(`Device with id ${id} already exists`);\n    }\n\n    Devices.devices[type][id] = device;\n\n    Devices.$dispatchChange(device);\n    return Object.keys(Devices.devices[type]).indexOf(id);\n  }\n\n  /**\n   * Gets a specific device by type and UUID\n   * @param type - The device type\n   * @param id - The device UUID\n   * @returns The device instance\n   * @throws {Error} If the device type is not supported\n   * @example\n   * ```typescript\n   * const device = Devices.get('arduino', 'uuid-123');\n   * ```\n   */\n  public static get(type: string, id: string): Core {\n    if (typeof Devices.devices[type] === \"undefined\") {\n      Devices.registerType(type);\n    }\n\n    if (typeof Devices.devices[type] === \"undefined\") Devices.typeError(type);\n\n    return Devices.devices[type][id];\n  }\n\n  public static getAll(type: string | null = null): IDevice | IDevices {\n    if (type === null) return Devices.devices;\n    if (typeof Devices.devices[type] === \"undefined\") Devices.typeError(type);\n\n    return Devices.devices[type];\n  }\n\n  public static getList(): Core[] {\n    // get all devices in list mode no matter the type\n    // by some reason the array is empty so we need to use Object.values and map\n    const devices: IDevice[] = Object.values(Devices.devices);\n    return devices\n      .map((device: IDevice): Core[] => {\n        return Object.values(device);\n      })\n      .flat();\n  }\n\n  public static getByNumber(type: string, device_number: number): Core | null {\n    if (typeof Devices.devices[type] === \"undefined\") Devices.typeError(type);\n\n    const devices = Object.values(Devices.devices[type]);\n    return devices.find((device) => device.deviceNumber === device_number) ?? null;\n  }\n\n  public static getCustom(type: string, device_number: number = 1): Core | null {\n    if (typeof Devices.devices[type] === \"undefined\") Devices.typeError(type);\n\n    const devices = Object.values(Devices.devices[type]);\n    return devices.find((device) => device.deviceNumber === device_number) ?? null;\n  }\n\n  public static async connectToAll(): Promise<boolean> {\n    const devices: Core[] = Devices.getList();\n\n    for (const device of devices) {\n      if (device.isConnected) continue;\n      await device.connect().catch(console.warn);\n    }\n\n    return Promise.resolve(Devices.areAllConnected());\n  }\n\n  public static async disconnectAll(): Promise<boolean> {\n    const devices: Core[] = Devices.getList();\n\n    for (const device of devices) {\n      if (device.isDisconnected) continue;\n      await device.disconnect().catch(console.warn);\n    }\n\n    return Promise.resolve(Devices.areAllDisconnected());\n  }\n\n  public static async areAllConnected(): Promise<boolean> {\n    const devices: Core[] = Devices.getList();\n\n    for (const device of devices) {\n      if (!device.isConnected) return Promise.resolve(false);\n    }\n\n    return Promise.resolve(true);\n  }\n\n  public static async areAllDisconnected(): Promise<boolean> {\n    const devices: Core[] = Devices.getList();\n\n    for (const device of devices) {\n      if (!device.isDisconnected) return Promise.resolve(false);\n    }\n\n    return Promise.resolve(true);\n  }\n\n  public static async getAllConnected(): Promise<Core[]> {\n    const devices: Core[] = Devices.getList();\n    return Promise.resolve(devices.filter((device: Core): boolean => device.isConnected));\n  }\n\n  public static async getAllDisconnected(): Promise<Core[]> {\n    const devices: Core[] = Devices.getList();\n    return Promise.resolve(devices.filter((device: Core): boolean => device.isDisconnected));\n  }\n}\n\nif (!Devices.instance) {\n  Devices.instance = new Devices();\n}\n","type empty = void | PromiseLike<void>;\n\nexport function wait(ms: number = 100): Promise<void> {\n  return new Promise(\n    (resolve: (value: empty) => void): ReturnType<typeof setTimeout> => setTimeout((): void => resolve(), ms),\n  );\n}\n\n/*\n * @deprecated This function is deprecated and will be removed in future versions.\n */\nexport function supportWebSerial(): boolean {\n  return \"serial\" in navigator;\n}\n","import { io, ManagerOptions, SocketOptions, Socket as SocketIOClient } from \"socket.io-client\";\nimport { Devices } from \"./Devices\";\nimport { Core } from \"./Core\";\n\ninterface SocketResponseData {\n  name: string;\n  uuid: string;\n  deviceNumber: number;\n  [key: string]: unknown;\n}\n\ntype BoundedFunction = {\n  onResponse: (data: SocketResponseData) => void;\n  onDisconnect: () => void;\n  onConnect: () => void;\n  onConnectError: (error: unknown) => void;\n};\n\nclass MySocket {\n  #uri: string = \"http://localhost:3001\";\n  #options: Partial<ManagerOptions & SocketOptions> = {\n    transports: [\"websocket\"],\n  };\n  #socket: SocketIOClient | null = null;\n  #connected: boolean = false;\n  #hasInstance: boolean = false;\n\n  #boundedFun: BoundedFunction;\n\n  constructor(uri?: string, options?: Partial<ManagerOptions & SocketOptions>) {\n    if (uri) {\n      this.#uri = uri;\n    }\n    if (options) {\n      this.#options = { ...this.#options, ...options };\n    }\n\n    this.#boundedFun = {\n      onResponse: this.onResponse.bind(this),\n      onDisconnect: () => {\n        // console.debug(\"Socket disconnected\", this.#socket?.id);\n        this.#connected = false;\n        window.dispatchEvent(new Event(\"serial:socket:disconnected\"));\n      },\n      onConnect: () => {\n        // console.debug(\"Socket connected\", this.#socket?.id);\n        this.#connected = true;\n        window.dispatchEvent(new Event(\"serial:socket:connected\"));\n      },\n      onConnectError: (error) => {\n        console.debug(\"Socket connection error\", error);\n        this.#connected = false;\n        window.dispatchEvent(new Event(\"serial:socket:disconnected\"));\n      },\n    };\n  }\n\n  set uri(uri: string) {\n    const url = new URL(uri);\n\n    if (![\"http:\", \"https:\", \"ws:\", \"wss:\"].includes(url.protocol)) {\n      throw new Error(\"URI must start with http://, https://, ws://, or wss://\");\n    }\n    this.#uri = uri;\n  }\n\n  get uri(): string {\n    return this.#uri;\n  }\n\n  set options(options: Partial<ManagerOptions & SocketOptions>) {\n    if (typeof options !== \"object\") {\n      throw new Error(\"Options must be an object\");\n    }\n    this.#options = options;\n  }\n\n  get options(): Partial<ManagerOptions & SocketOptions> {\n    return this.#options;\n  }\n\n  get socketId(): string | null {\n    return this.#socket && this.#socket.id ? this.#socket.id : null;\n  }\n\n  configure(uri?: string, options?: Partial<ManagerOptions & SocketOptions>): void {\n    if (this.#hasInstance) {\n      throw new Error(\"Cannot configure socket after it has been initialized. Call configure() before prepare().\");\n    }\n    if (uri) {\n      this.uri = uri;\n    }\n    if (options) {\n      this.#options = { ...this.#options, ...options };\n    }\n  }\n\n  disconnect() {\n    if (this.#socket) {\n      this.#socket.off(\"response\", this.#boundedFun.onResponse);\n      this.#socket.off(\"disconnect\", this.#boundedFun.onDisconnect);\n      this.#socket.off(\"connect\", this.#boundedFun.onConnect);\n      this.#socket.off(\"connect_error\", this.#boundedFun.onConnectError);\n\n      this.#socket.disconnect();\n      this.#socket = null;\n      this.#hasInstance = false;\n    }\n    this.#connected = false;\n  }\n\n  prepare() {\n    if (this.#connected || this.#hasInstance) return;\n\n    this.#socket = io(this.#uri, this.#options);\n    // this.#connected = true; // don't asume connected until onConnect is called\n    this.#hasInstance = true;\n\n    this.#socket.on(\"disconnect\", this.#boundedFun.onDisconnect);\n    this.#socket.on(\"response\", this.#boundedFun.onResponse);\n    this.#socket.on(\"connect\", this.#boundedFun.onConnect);\n    this.#socket.on(\"connect_error\", this.#boundedFun.onConnectError);\n  }\n\n  connectDevice(config: object): void {\n    if (!this.#socket) {\n      throw new Error(\"Socket not connected. Call prepare() first.\");\n    }\n    this.#socket.emit(\"connectDevice\", { config });\n  }\n\n  disconnectDevice(config: object): void {\n    if (!this.#socket) {\n      throw new Error(\"Socket not connected. Call prepare() first.\");\n    }\n    this.#socket.emit(\"disconnectDevice\", { config });\n  }\n\n  disconnectAllDevices(): void {\n    if (!this.#socket) {\n      throw new Error(\"Socket not connected. Call prepare() first.\");\n    }\n    this.#socket.emit(\"disconnectAll\");\n  }\n\n  write(data: object): void {\n    if (!this.#socket) {\n      throw new Error(\"Socket not connected. Call prepare() first.\");\n    }\n    this.#socket.emit(\"cmd\", data);\n  }\n\n  onResponse(data: SocketResponseData): void {\n    let device: Core | null = Devices.get(data.name, data.uuid);\n    if (!device) {\n      device = Devices.getByNumber(data.name, data.deviceNumber);\n    }\n    if (!device) {\n      return;\n    }\n    device.socketResponse(data);\n  }\n\n  isConnected(): boolean {\n    return this.#connected;\n  }\n\n  isDisconnected(): boolean {\n    return !this.#connected;\n  }\n}\n\nexport const Socket = new MySocket();\n","import { Dispatcher } from \"./Dispatcher\";\nimport { Devices } from \"./Devices\";\nimport { wait } from \"./utils\";\nimport { Socket } from \"./Socket\";\n\ninterface LastError {\n  message: string | null;\n  action: string | null;\n  code: string | Uint8Array | Array<string> | Array<number> | null | number;\n  no_code: number;\n}\n\ninterface DeviceData {\n  type: string;\n  id: string;\n  listen_on_port: number | null;\n}\n\ntype SerialResponseAs = \"hex\" | \"uint8\" | \"string\" | \"arraybuffer\";\n\ninterface SerialResponse {\n  length: number | null;\n  buffer: Uint8Array;\n  as: SerialResponseAs;\n  replacer: RegExp | string;\n  limiter: null | string | RegExp;\n  prefixLimiter: boolean; // If true, the limiter is at the beginning of the message\n  sufixLimiter: boolean; // If true, the limiter is at the end of the message\n  delimited: boolean;\n}\n\ninterface QueueData {\n  bytes: string | Uint8Array | Array<string> | Array<number>;\n  action: string;\n}\n\ntype ParserSocketPort = {\n  name: \"byte-length\" | \"inter-byte-timeout\";\n  length?: number; // Length of each byte in the response, only for byte-length\n  interval?: number; // Interval in milliseconds for inter-byte-timeout\n};\n\ntype PortInfo = {\n  path: string | null;\n  vendorId: number | string | null;\n  productId: number | string | null;\n  parser: ParserSocketPort;\n};\n\ntype SerialData = {\n  transformStream: false | TransformStream;\n  socket: boolean;\n  portInfo: PortInfo;\n  aux_connecting: string;\n  connecting: boolean;\n  connected: boolean;\n  port: SerialPort | null;\n  last_action: string | null;\n  response: SerialResponse;\n  reader: ReadableStreamDefaultReader<Uint8Array> | null;\n  input_done: Promise<void> | null;\n  output_done: Promise<void> | null;\n  input_stream: ReadableStream<Uint8Array> | null;\n  output_stream: WritableStream<Uint8Array> | null;\n  keep_reading: boolean;\n  time_until_send_bytes: number | undefined | ReturnType<typeof setTimeout>;\n  delay_first_connection: number;\n  bytes_connection: string | Uint8Array | string[] | number[] | null;\n  filters: SerialPortFilter[];\n  config_port: SerialOptions;\n  queue: QueueData[];\n  running_queue: boolean;\n  auto_response: any;\n  free_timeout_ms: number;\n  useRTSCTS: boolean;\n};\n\ninterface TimeResponse {\n  response_connection: number;\n  response_engines: number;\n  response_general: number;\n}\n\ninterface Timeout {\n  until_response: number | ReturnType<typeof setTimeout>;\n}\n\ninterface InternalIntervals {\n  reconnection: number;\n}\n\nexport type Internal = {\n  bypassSerialBytesConnection: boolean;\n  auto_response: boolean;\n  device_number: number;\n  aux_port_connector: number;\n  last_error: LastError;\n  serial: SerialData;\n  device: DeviceData;\n  time: TimeResponse;\n  timeout: Timeout;\n  interval: InternalIntervals;\n};\n\ninterface CoreConstructorParams {\n  filters?: SerialPortFilter[] | null;\n  config_port?: SerialOptions;\n  no_device?: number;\n  device_listen_on_channel?: number | string;\n  bypassSerialBytesConnection?: boolean;\n  socket?: boolean;\n  transformStream?: false | TransformStream;\n}\n\nconst defaultConfigPort: SerialOptions = {\n  baudRate: 9600,\n  dataBits: 8,\n  stopBits: 1,\n  parity: \"none\",\n  bufferSize: 32768,\n  flowControl: \"none\",\n};\n\ninterface CustomCode {\n  code: string | Uint8Array | Array<string> | Array<number>;\n}\n\ninterface ICore {\n  lastAction: string | null;\n\n  set listenOnChannel(channel: string | number);\n\n  set serialFilters(filters: SerialPortFilter[]);\n\n  get serialFilters(): SerialPortFilter[];\n\n  set serialConfigPort(config_port: SerialOptions);\n\n  get serialConfigPort(): SerialOptions;\n\n  get isConnected(): boolean;\n\n  get isConnecting(): boolean;\n\n  get isDisconnected(): boolean;\n\n  get useRTSCTS(): boolean;\n\n  set useRTSCTS(value: boolean);\n\n  get deviceNumber(): number;\n\n  get uuid(): string;\n\n  get typeDevice(): string;\n\n  get queue(): QueueData[];\n\n  get timeoutBeforeResponseBytes(): number;\n\n  set timeoutBeforeResponseBytes(value: number);\n\n  get fixedBytesMessage(): number | null;\n\n  set fixedBytesMessage(length: number | null);\n\n  get responseDelimited(): boolean;\n\n  set responseDelimited(value: boolean);\n\n  get responsePrefixLimited(): boolean;\n\n  set responsePrefixLimited(value: boolean);\n\n  get responseSufixLimited(): boolean;\n\n  set responseSufixLimited(value: boolean);\n\n  get responseLimiter(): string | RegExp | null;\n\n  set responseLimiter(limiter: string | RegExp | null);\n\n  get bypassSerialBytesConnection(): boolean;\n\n  set bypassSerialBytesConnection(value: boolean);\n\n  timeout(bytes: string[], event: string): Promise<void>;\n\n  disconnect(detail?: null): Promise<void>;\n\n  connect(): Promise<boolean>;\n\n  serialDisconnect(): Promise<void>;\n\n  serialPortsSaved(ports: SerialPort[]): Promise<void>;\n\n  serialErrors(error: unknown | Error | DOMException): void;\n\n  serialConnect(): Promise<void>;\n\n  serialForget(): Promise<boolean>;\n\n  decToHex(dec: number | string): string;\n\n  hexToDec(hex: string): number;\n\n  hexMaker(val?: string, min?: number): string;\n\n  add0x(bytes: string[]): string[];\n\n  bytesToHex(bytes: string[]): string[];\n\n  appendToQueue(arr: string[], action: string): Promise<void>;\n\n  serialSetConnectionConstant(listen_on_port?: number): string | Uint8Array | string[] | number[] | null;\n\n  serialMessage(code: string[]): void;\n\n  serialCorruptMessage(data: Uint8Array | number[] | string[] | never | null | string | ArrayBuffer): void;\n\n  clearSerialQueue(): void;\n\n  sumHex(arr: string[]): string;\n\n  softReload(): void;\n\n  sendConnect(): Promise<void>;\n\n  sendCustomCode(customCode: CustomCode): Promise<void>;\n\n  stringToArrayHex(string: string): string[];\n\n  stringToArrayBuffer(string: string, end: string): ArrayBufferLike;\n\n  parseStringToBytes(string: string, end: string): string[];\n\n  parseUint8ToHex(array: Uint8Array): string[];\n\n  parseHexToUint8(array: string[]): Uint8Array;\n\n  stringArrayToUint8Array(strings: string[]): Uint8Array;\n\n  parseUint8ArrayToString(array: string[]): string;\n\n  parseStringToTextEncoder(string: string, end: string): Uint8Array;\n\n  hexToAscii(hex: string | number): string;\n\n  asciiToHex(asciiString: string): string;\n\n  getResponseAsArrayBuffer(): void;\n\n  getResponseAsArrayHex(): void;\n\n  getResponseAsUint8Array(): void;\n\n  getResponseAsString(): void;\n}\n\nexport class Core extends Dispatcher implements ICore {\n  protected __internal__: Internal = {\n    bypassSerialBytesConnection: false,\n    auto_response: false,\n    device_number: 1,\n    aux_port_connector: 0,\n    last_error: {\n      message: null,\n      action: null,\n      code: null,\n      no_code: 0,\n    },\n    serial: {\n      transformStream: false,\n      socket: false,\n      portInfo: {\n        path: null,\n        vendorId: null,\n        productId: null,\n        parser: {\n          name: \"inter-byte-timeout\",\n          interval: 50,\n        },\n      },\n      aux_connecting: \"idle\",\n      connecting: false,\n      connected: false,\n      port: null,\n      last_action: null,\n      response: {\n        length: null,\n        buffer: new Uint8Array([]),\n        as: \"uint8\",\n        replacer: /[\\n\\r]+/g,\n        limiter: null,\n        prefixLimiter: false,\n        sufixLimiter: true,\n        delimited: false,\n      },\n      reader: null,\n      input_done: null,\n      output_done: null,\n      input_stream: null,\n      output_stream: null,\n      keep_reading: true,\n      time_until_send_bytes: undefined,\n      delay_first_connection: 200,\n      bytes_connection: null,\n      filters: [],\n      config_port: defaultConfigPort,\n      queue: [],\n      running_queue: false,\n      auto_response: null,\n      free_timeout_ms: 50, // In previous versions 400 was used\n      useRTSCTS: false, // Use RTS/CTS flow control\n    },\n    device: {\n      type: \"unknown\",\n      id: window.crypto.randomUUID(),\n      listen_on_port: null,\n    },\n    time: {\n      response_connection: 500,\n      response_engines: 2e3,\n      response_general: 2e3,\n    },\n    timeout: {\n      until_response: 0,\n    },\n    interval: {\n      reconnection: 0,\n    },\n  };\n\n  #boundFinishConnecting: EventListenerOrEventListenerObject | null = null;\n\n  constructor(\n    {\n      filters = null,\n      config_port = defaultConfigPort,\n      no_device = 1,\n      device_listen_on_channel = 1,\n      bypassSerialBytesConnection = false,\n      socket = false,\n      transformStream = false,\n    }: CoreConstructorParams = {\n      filters: null,\n      config_port: defaultConfigPort,\n      no_device: 1,\n      device_listen_on_channel: 1,\n      bypassSerialBytesConnection: false,\n      socket: false,\n      transformStream: false,\n    },\n  ) {\n    super();\n\n    if (!(\"serial\" in navigator)) {\n      throw new Error(\"Web Serial not supported\");\n    }\n\n    if (filters) {\n      this.serialFilters = filters;\n    }\n\n    if (config_port) {\n      this.serialConfigPort = config_port;\n    }\n\n    if (bypassSerialBytesConnection) {\n      this.__internal__.bypassSerialBytesConnection = bypassSerialBytesConnection;\n    }\n\n    if (no_device) {\n      this.#serialSetBytesConnection(no_device);\n    }\n\n    if (device_listen_on_channel && [\"number\", \"string\"].includes(typeof device_listen_on_channel)) {\n      this.listenOnChannel = device_listen_on_channel;\n    }\n\n    this.__internal__.serial.socket = socket;\n    this.__internal__.serial.transformStream = transformStream;\n\n    this.#registerDefaultListeners();\n    this.#internalEvents();\n  }\n\n  set listenOnChannel(channel: string | number) {\n    if (typeof channel === \"string\") {\n      channel = parseInt(channel);\n    }\n    if (isNaN(channel) || channel < 1 || channel > 255) {\n      throw new Error(\"Invalid port number\");\n    }\n    this.__internal__.device.listen_on_port = channel;\n    if (this.__internal__.bypassSerialBytesConnection) return;\n    this.__internal__.serial.bytes_connection = this.serialSetConnectionConstant(channel);\n  }\n\n  get lastAction(): string | null {\n    return this.__internal__.serial.last_action;\n  }\n\n  get listenOnChannel(): number {\n    return this.__internal__.device.listen_on_port ?? 1;\n  }\n\n  set serialFilters(filters: SerialPortFilter[]) {\n    if (this.isConnected) throw new Error(\"Cannot change serial filters while connected\");\n    this.__internal__.serial.filters = filters;\n  }\n\n  get serialFilters(): SerialPortFilter[] {\n    return this.__internal__.serial.filters;\n  }\n\n  set serialConfigPort(config_port: SerialOptions) {\n    if (this.isConnected) throw new Error(\"Cannot change serial filters while connected\");\n    this.__internal__.serial.config_port = config_port;\n  }\n\n  get serialConfigPort(): SerialOptions {\n    return this.__internal__.serial.config_port;\n  }\n\n  get useRTSCTS(): boolean {\n    return this.__internal__.serial.useRTSCTS;\n  }\n\n  set useRTSCTS(value: boolean) {\n    this.__internal__.serial.useRTSCTS = value;\n  }\n\n  get isConnected(): boolean {\n    const prevConnected = this.__internal__.serial.connected;\n    const connected = this.#checkIfPortIsOpen(this.__internal__.serial.port);\n    if (prevConnected && !connected) {\n      this.#disconnected({ error: \"Port is closed, not readable or writable.\" });\n    }\n    this.__internal__.serial.connected = connected;\n    return this.__internal__.serial.connected;\n  }\n\n  get isConnecting(): boolean {\n    return this.__internal__.serial.connecting;\n  }\n\n  get isDisconnected(): boolean {\n    const prevConnected = this.__internal__.serial.connected;\n    const connected = this.#checkIfPortIsOpen(this.__internal__.serial.port);\n    if (!prevConnected && connected) {\n      this.dispatch(\"serial:connected\");\n      this.#connectingChange(false);\n      Devices.$dispatchChange(this);\n    }\n    this.__internal__.serial.connected = connected;\n    return !this.__internal__.serial.connected;\n  }\n\n  get deviceNumber(): number {\n    return this.__internal__.device_number;\n  }\n\n  get uuid(): string {\n    return this.__internal__.device.id;\n  }\n\n  get typeDevice(): string {\n    return this.__internal__.device.type;\n  }\n\n  get queue(): QueueData[] {\n    return this.__internal__.serial.queue;\n  }\n\n  get responseDelimited(): boolean {\n    return this.__internal__.serial.response.delimited;\n  }\n\n  set responseDelimited(value: boolean) {\n    if (typeof value !== \"boolean\") {\n      throw new Error(\"responseDelimited must be a boolean\");\n    }\n    this.__internal__.serial.response.delimited = value;\n  }\n\n  get responsePrefixLimited(): boolean {\n    return this.__internal__.serial.response.prefixLimiter;\n  }\n\n  set responsePrefixLimited(value: boolean) {\n    if (typeof value !== \"boolean\") {\n      throw new Error(\"responsePrefixLimited must be a boolean\");\n    }\n    this.__internal__.serial.response.prefixLimiter = value;\n  }\n\n  get responseSufixLimited(): boolean {\n    return this.__internal__.serial.response.sufixLimiter;\n  }\n\n  set responseSufixLimited(value: boolean) {\n    if (typeof value !== \"boolean\") {\n      throw new Error(\"responseSufixLimited must be a boolean\");\n    }\n    this.__internal__.serial.response.sufixLimiter = value;\n  }\n\n  get responseLimiter(): string | RegExp | null {\n    return this.__internal__.serial.response.limiter;\n  }\n\n  set responseLimiter(limiter: string | RegExp | null) {\n    if (typeof limiter !== \"string\" && !(limiter instanceof RegExp)) {\n      throw new Error(\"responseLimiter must be a string or a RegExp\");\n    }\n\n    this.__internal__.serial.response.limiter = limiter;\n  }\n\n  get fixedBytesMessage(): number | null {\n    return this.__internal__.serial.response.length;\n  }\n\n  set fixedBytesMessage(length: number | null) {\n    if (length !== null && (typeof length !== \"number\" || length < 1)) {\n      throw new Error(\"Invalid length for fixed bytes message\");\n    }\n    this.__internal__.serial.response.length = length;\n  }\n\n  get timeoutBeforeResponseBytes(): number {\n    return this.__internal__.serial.free_timeout_ms || 50;\n  }\n\n  set timeoutBeforeResponseBytes(value: number) {\n    if (value !== undefined && (typeof value !== \"number\" || value < 1)) {\n      throw new Error(\"Invalid timeout for response bytes\");\n    }\n    this.__internal__.serial.free_timeout_ms = value ?? 50;\n  }\n\n  get bypassSerialBytesConnection(): boolean {\n    return this.__internal__.bypassSerialBytesConnection;\n  }\n\n  set bypassSerialBytesConnection(value: boolean) {\n    if (typeof value !== \"boolean\") {\n      throw new Error(\"bypassSerialBytesConnection must be a boolean\");\n    }\n    this.__internal__.bypassSerialBytesConnection = value;\n  }\n\n  get useSocket(): boolean {\n    return this.__internal__.serial.socket;\n  }\n\n  get connectionBytes(): Uint8Array {\n    const bytes = this.__internal__.serial.bytes_connection;\n\n    if (bytes instanceof Uint8Array) {\n      return bytes;\n    }\n\n    if (typeof bytes === \"string\") {\n      return this.stringArrayToUint8Array(this.parseStringToBytes(bytes, \"\"));\n    }\n\n    if (Array.isArray(bytes) && typeof bytes[0] === \"string\") {\n      return this.stringArrayToUint8Array(bytes as string[]);\n    }\n\n    if (Array.isArray(bytes) && typeof bytes[0] === \"number\") {\n      return new Uint8Array(bytes as number[]);\n    }\n\n    return new Uint8Array([]);\n  }\n\n  set portPath(path: string | null) {\n    if (this.isConnected) throw new Error(\"Cannot change port path while connected\");\n    if (typeof path !== \"string\" && path !== null) {\n      throw new TypeError(\"vendorId must be string or null\");\n    }\n    this.__internal__.serial.portInfo.path = path;\n  }\n\n  get portPath(): string | null {\n    return this.__internal__.serial.portInfo.path;\n  }\n\n  set portVendorId(vendorId: number | string | null) {\n    if (this.isConnected) throw new Error(\"Cannot change port vendorId while connected\");\n    if (typeof vendorId! == \"number\" && typeof vendorId !== \"string\" && vendorId !== null) {\n      throw new TypeError(\"vendorId must be a number, string or null\");\n    }\n    this.__internal__.serial.portInfo.vendorId = vendorId;\n  }\n\n  get portVendorId(): number | string | null {\n    return this.__internal__.serial.portInfo.vendorId;\n  }\n\n  set portProductId(productId: number | string | null) {\n    if (this.isConnected) throw new Error(\"Cannot change port productId while connected\");\n    if (typeof productId! == \"number\" && typeof productId !== \"string\" && productId !== null) {\n      throw new TypeError(\"productId must be a number, string or null\");\n    }\n    this.__internal__.serial.portInfo.productId = productId;\n  }\n\n  get portProductId(): number | string | null {\n    return this.__internal__.serial.portInfo.productId;\n  }\n\n  set socketPortParser(string: \"byte-length\" | \"inter-byte-timeout\") {\n    if ([\"byte-length\", \"inter-byte-timeout\"].includes(string)) {\n      throw new TypeError(\"socketPortParser must be a string, either 'byte-length' or 'inter-byte-timeout'\");\n    }\n    this.__internal__.serial.portInfo.parser.name = string;\n  }\n\n  get socketPortParser(): \"byte-length\" | \"inter-byte-timeout\" {\n    return this.__internal__.serial.portInfo.parser.name;\n  }\n\n  set socketPortParserInterval(value: number) {\n    if (typeof value !== \"number\" || value < 1) {\n      throw new TypeError(\"Interval must be a positive number\");\n    }\n\n    this.__internal__.serial.portInfo.parser.interval = value;\n  }\n\n  get socketPortParserInterval(): number {\n    return this.__internal__.serial.portInfo.parser.interval || 50;\n  }\n\n  set socketPortParserLength(value: number) {\n    if (typeof value !== \"number\" || value < 1) {\n      throw new TypeError(\"Length must be a positive number or null\");\n    }\n    this.__internal__.serial.portInfo.parser.length = value;\n  }\n\n  get socketPortParserLength(): number {\n    return this.__internal__.serial.portInfo.parser.length || 14;\n  }\n\n  get parserForSocket() {\n    if (this.socketPortParser === \"byte-length\") {\n      return {\n        name: this.socketPortParser,\n        length: this.socketPortParserLength,\n      };\n    }\n    return {\n      name: this.socketPortParser,\n      interval: this.socketPortParserInterval,\n    };\n  }\n\n  get configDeviceSocket(): object {\n    return {\n      uuid: this.uuid,\n      name: this.typeDevice,\n      deviceNumber: this.deviceNumber,\n      connectionBytes: Array.from(this.connectionBytes),\n      config: {\n        baudRate: this.__internal__.serial.config_port.baudRate,\n        dataBits: this.__internal__.serial.config_port.dataBits,\n        stopBits: this.__internal__.serial.config_port.stopBits,\n        parity: this.__internal__.serial.config_port.parity,\n        bufferSize: this.__internal__.serial.config_port.bufferSize,\n        flowControl: this.__internal__.serial.config_port.flowControl,\n      },\n      info: {\n        vendorId: this.portVendorId, // vendor ID or null for auto-detect\n        productId: this.portProductId, // product ID or null for auto-detect\n        portName: this.portPath, // COM3, /dev/ttyUSB0, etc. null for auto-detect\n      },\n      response: {\n        automatic: this.__internal__.auto_response, // true to auto-respond to commands this only for devices that doesn't respond nothing\n        autoResponse: this.__internal__.serial.auto_response, // null or data to respond automatically, ie. [0x02, 0x06, 0xdd, 0xdd, 0xf0, 0xcf, 0x03] for relay\n        parser: this.parserForSocket,\n        timeout: {\n          general: this.__internal__.time.response_general,\n          engines: this.__internal__.time.response_engines,\n          connection: this.__internal__.time.response_connection,\n        },\n      },\n    };\n  }\n\n  #checkIfPortIsOpen(port: SerialPort | null): boolean {\n    if (this.useSocket) {\n      return this.__internal__.serial.connected && Socket.isConnected();\n    }\n\n    return !!(port && port.readable && port.writable);\n  }\n\n  public async timeout(bytes: string | Uint8Array | Array<string> | Array<number>, event: string): Promise<void> {\n    this.__internal__.last_error.message = \"Operation response timed out.\";\n    this.__internal__.last_error.action = event;\n    this.__internal__.last_error.code = bytes;\n    if (this.__internal__.timeout.until_response) {\n      clearTimeout(this.__internal__.timeout.until_response);\n      this.__internal__.timeout.until_response = 0;\n    }\n    if (event === \"connect\") {\n      this.__internal__.serial.connected = false;\n      this.dispatch(\"serial:reconnect\", {});\n      Devices.$dispatchChange(this);\n    } else if (event === \"connection:start\") {\n      await this.serialDisconnect();\n      this.__internal__.serial.connected = false;\n      this.__internal__.aux_port_connector += 1;\n      Devices.$dispatchChange(this);\n      await this.serialConnect();\n    }\n\n    if (this.__internal__.serial.queue.length > 0) {\n      this.dispatch(\"internal:queue\", {});\n    }\n\n    this.dispatch(\"serial:timeout\", {\n      ...this.__internal__.last_error,\n      bytes,\n      action: event,\n    });\n  }\n\n  public async disconnect(detail = null): Promise<void> {\n    await this.serialDisconnect();\n    this.#disconnected(detail);\n  }\n\n  #disconnected(detail: object | null = null): void {\n    this.__internal__.serial.connected = false;\n    this.__internal__.aux_port_connector = 0;\n    this.dispatch(\"serial:disconnected\", detail);\n    Devices.$dispatchChange(this);\n  }\n\n  #onFinishConnecting(event: any): void {\n    this.__internal__.serial.aux_connecting = event.detail.active ? \"connecting\" : \"finished\";\n  }\n\n  socketResponse(data: any) {\n    const auxPrevConnected: boolean = this.__internal__.serial.connected;\n\n    if (data.type === \"disconnect\" || (data.type === \"error\" && data.data === \"DISCONNECTED\")) {\n      this.__internal__.serial.connected = false;\n    } else if (data.type === \"success\") {\n      this.__internal__.serial.connected = true;\n    }\n\n    Devices.$dispatchChange(this);\n    if (!auxPrevConnected && this.__internal__.serial.connected) {\n      this.dispatch(\"serial:connected\");\n      this.#connectingChange(false);\n    }\n\n    // console.log(data, this.lastAction);\n    if (data.type === \"success\") {\n      this.#serialGetResponse(new Uint8Array(data.data));\n    } else if (data.type === \"error\") {\n      const error = new Error(\"The port is closed or is not readable/writable\");\n      this.serialErrors(error);\n    } else if (data.type === \"timeout\") {\n      this.timeout(data.data.bytes ?? [], this.lastAction || \"unknown\");\n    }\n\n    this.__internal__.serial.last_action = null;\n  }\n\n  public async connect(): Promise<boolean> {\n    if (this.isConnected) {\n      return true;\n    }\n\n    this.__internal__.serial.aux_connecting = \"idle\";\n\n    return new Promise((resolve: (value: boolean) => void, reject: (reason: string) => void): void => {\n      if (!this.#boundFinishConnecting) {\n        this.#boundFinishConnecting = this.#onFinishConnecting.bind(this);\n      }\n\n      this.on(\"internal:connecting\", this.#boundFinishConnecting);\n\n      const interval: ReturnType<typeof setInterval> = setInterval((): void => {\n        if (this.__internal__.serial.aux_connecting === \"finished\") {\n          clearInterval(interval);\n          this.__internal__.serial.aux_connecting = \"idle\";\n          if (null !== this.#boundFinishConnecting) {\n            this.off(\"internal:connecting\", this.#boundFinishConnecting);\n          }\n\n          if (this.isConnected) {\n            resolve(true);\n          } else {\n            reject(`${this.typeDevice} device ${this.deviceNumber} not connected`);\n          }\n        } else if (this.__internal__.serial.aux_connecting === \"connecting\") {\n          this.__internal__.serial.aux_connecting = \"idle\";\n          this.dispatch(\"internal:connecting\", { active: true });\n          this.dispatch(\"serial:connecting\", { active: true });\n        }\n      }, 100);\n\n      this.serialConnect();\n    });\n  }\n\n  public async serialDisconnect(): Promise<void> {\n    try {\n      if (this.useSocket) {\n        if (Socket.isConnected()) {\n          Socket.disconnectDevice(this.configDeviceSocket);\n        }\n      } else {\n        const reader: ReadableStreamDefaultReader<Uint8Array> | null = this.__internal__.serial.reader;\n        const output_stream: WritableStream<Uint8Array> | null = this.__internal__.serial.output_stream;\n        if (reader) {\n          const reader_promise: Promise<void> = reader.cancel();\n          await reader_promise.catch((err: unknown): void => this.serialErrors(err));\n          await this.__internal__.serial.input_done;\n        }\n\n        if (output_stream) {\n          await output_stream.getWriter().close();\n          await this.__internal__.serial.output_done;\n        }\n\n        if (this.__internal__.serial.connected && this.__internal__.serial && this.__internal__.serial.port) {\n          await this.__internal__.serial.port.close();\n        }\n      }\n    } catch (err: unknown) {\n      this.serialErrors(err);\n    } finally {\n      this.__internal__.serial.reader = null;\n      this.__internal__.serial.input_done = null;\n\n      this.__internal__.serial.output_stream = null;\n      this.__internal__.serial.output_done = null;\n\n      this.__internal__.serial.connected = false;\n      this.__internal__.serial.port = null;\n      Devices.$dispatchChange(this);\n    }\n  }\n\n  async #serialSocketWrite(data: string | Uint8Array | Array<string> | Array<number>): Promise<void> {\n    if (Socket.isDisconnected()) {\n      this.#disconnected({ error: \"Socket is disconnected.\" });\n      throw new Error(\"The socket is disconnected\");\n    }\n\n    if (this.isDisconnected) {\n      this.#disconnected({ error: \"Port is closed, not readable or writable.\" });\n      throw new Error(\"The port is closed or is not readable/writable\");\n    }\n\n    const bytes: Uint8Array = this.validateBytes(data);\n    Socket.write({ config: this.configDeviceSocket, bytes: Array.from(bytes) });\n  }\n\n  async #serialWrite(data: string | Uint8Array | Array<string> | Array<number>): Promise<void> {\n    if (this.useSocket) {\n      await this.#serialSocketWrite(data);\n      return;\n    }\n    const port: SerialPort | null = this.__internal__.serial.port;\n    if (!port || (port && (!port.readable || !port.writable))) {\n      this.#disconnected({ error: \"Port is closed, not readable or writable.\" });\n      throw new Error(\"The port is closed or is not readable/writable\");\n    }\n    const bytes: Uint8Array = this.validateBytes(data);\n\n    if (this.useRTSCTS) {\n      await this.#waitForCTS(port, 5000);\n    }\n\n    if (port.writable === null) return; // never happens, it's already checked, but to suppress TS error\n    const writer: WritableStreamDefaultWriter<Uint8Array> = port.writable.getWriter();\n    await writer.write(bytes);\n    writer.releaseLock();\n  }\n\n  async #waitForCTS(port: SerialPort, timeoutMs: number = 5000): Promise<void> {\n    const start = Date.now();\n    while (true) {\n      if (Date.now() - start > timeoutMs) {\n        throw new Error(\"Timeout waiting for clearToSend signal\");\n      }\n\n      const { clearToSend } = await port.getSignals();\n      if (clearToSend) return;\n      await wait(100);\n    }\n  }\n\n  #serialGetResponse(code: Uint8Array = new Uint8Array([]), corrupt: boolean = false) {\n    if (code && code.length > 0) {\n      const auxPrevConnected: boolean = this.__internal__.serial.connected;\n      this.__internal__.serial.connected = this.#checkIfPortIsOpen(this.__internal__.serial.port);\n      Devices.$dispatchChange(this);\n      if (!auxPrevConnected && this.__internal__.serial.connected) {\n        this.dispatch(\"serial:connected\");\n        this.#connectingChange(false);\n      }\n\n      if (this.__internal__.interval.reconnection) {\n        clearInterval(this.__internal__.interval.reconnection);\n        this.__internal__.interval.reconnection = 0;\n      }\n\n      if (this.__internal__.timeout.until_response) {\n        clearTimeout(this.__internal__.timeout.until_response);\n        this.__internal__.timeout.until_response = 0;\n      }\n\n      if (this.__internal__.serial.response.as === \"hex\") {\n        if (corrupt) {\n          this.serialCorruptMessage(this.parseUint8ToHex(code));\n        } else {\n          this.serialMessage(this.parseUint8ToHex(code));\n        }\n      } else if (this.__internal__.serial.response.as === \"uint8\") {\n        if (corrupt) {\n          this.serialCorruptMessage(code);\n        } else {\n          this.serialMessage(code);\n        }\n      } else if (this.__internal__.serial.response.as === \"string\") {\n        const str = this.parseUint8ArrayToString(code);\n        if (this.__internal__.serial.response.limiter !== null) {\n          const splited = str.split(this.__internal__.serial.response.limiter);\n          for (const s in splited) {\n            if (!splited[s]) continue;\n            if (corrupt) {\n              this.serialCorruptMessage(splited[s]);\n            } else {\n              this.serialMessage(splited[s]);\n            }\n          }\n        } else {\n          if (corrupt) {\n            this.serialCorruptMessage(str);\n          } else {\n            this.serialMessage(str);\n          }\n        }\n      } else {\n        const arraybuffer: ArrayBuffer | ArrayBufferLike = this.stringToArrayBuffer(this.parseUint8ArrayToString(code));\n        if (corrupt) {\n          this.serialCorruptMessage(arraybuffer as ArrayBuffer);\n        } else {\n          this.serialMessage(arraybuffer as ArrayBuffer);\n        }\n      }\n    }\n\n    if (this.__internal__.serial.queue.length === 0) {\n      this.__internal__.serial.running_queue = false;\n      return;\n    }\n    this.dispatch(\"internal:queue\", {});\n  }\n\n  public getResponseAsArrayBuffer(): void {\n    this.__internal__.serial.response.as = \"arraybuffer\";\n  }\n\n  public getResponseAsArrayHex(): void {\n    this.__internal__.serial.response.as = \"hex\";\n  }\n\n  public getResponseAsUint8Array(): void {\n    this.__internal__.serial.response.as = \"uint8\";\n  }\n\n  public getResponseAsString(): void {\n    this.__internal__.serial.response.as = \"string\";\n  }\n\n  async #serialPortsFiltered(): Promise<SerialPort[]> {\n    const filters: SerialPortFilter[] = this.serialFilters;\n    // @ts-expect-error getPorts can use parameters\n    const ports: SerialPort[] = await navigator.serial.getPorts({ filters });\n    if (filters.length === 0) return ports;\n\n    const filteredPorts: SerialPort[] = ports.filter((port: SerialPort): boolean => {\n      const info: SerialPortInfo = port.getInfo();\n      return filters.some((filter: SerialPortFilter): boolean => {\n        return info.usbProductId === filter.usbProductId && info.usbVendorId === filter.usbVendorId;\n      });\n    });\n\n    // return only ports that are not open\n    return filteredPorts.filter((port: SerialPort): boolean => !this.#checkIfPortIsOpen(port));\n  }\n\n  public async serialPortsSaved(ports: SerialPort[]): Promise<void> {\n    const filters: SerialPortFilter[] = this.serialFilters;\n    if (this.__internal__.aux_port_connector < ports.length) {\n      const aux = this.__internal__.aux_port_connector;\n      this.__internal__.serial.port = ports[aux];\n    } else {\n      this.__internal__.aux_port_connector = 0;\n      this.__internal__.serial.port = await navigator.serial.requestPort({\n        filters,\n      });\n    }\n    if (!this.__internal__.serial.port) {\n      throw new Error(\"Select another port please\");\n    }\n  }\n\n  public serialErrors(error: any): void {\n    const err = error.toString().toLowerCase();\n    switch (true) {\n      case err.includes(\"must be handling a user gesture to show a permission request\"):\n      case err.includes(\"the port is closed.\"):\n      case err.includes(\"the port is closed or is not writable\"):\n      case err.includes(\"the port is closed or is not readable\"):\n      case err.includes(\"the port is closed or is not readable/writable\"):\n      case err.includes(\"select another port please\"):\n      case err.includes(\"no port selected by the user\"):\n      case err.includes(\n        \"this readable stream reader has been released and cannot be used to cancel its previous owner stream\",\n      ):\n        this.dispatch(\"serial:need-permission\", {});\n        Devices.$dispatchChange(this);\n        break;\n      case err.includes(\"the port is already open.\"):\n      case err.includes(\"failed to open serial port\"):\n        this.serialDisconnect().then(async () => {\n          this.__internal__.aux_port_connector += 1;\n          await this.serialConnect();\n        });\n        break;\n      case err.includes(\"cannot read properties of undefined (reading 'writable')\"):\n      case err.includes(\"cannot read properties of null (reading 'writable')\"):\n      case err.includes(\"cannot read property 'writable' of null\"):\n      case err.includes(\"cannot read property 'writable' of undefined\"):\n        this.serialDisconnect().then(async () => {\n          await this.serialConnect();\n        });\n        break;\n      case err.includes(\"'close' on 'serialport': a call to close() is already in progress.\"):\n        // ... do something?\n        break;\n      case err.includes(\"failed to execute 'open' on 'serialport': a call to open() is already in progress.\"):\n        // ... do something?\n        break;\n      case err.includes(\"the port is already closed.\"):\n        // ... do something?\n        break;\n      case err.includes(\"the device has been lost\"):\n        this.dispatch(\"serial:lost\", {});\n        Devices.$dispatchChange(this);\n        // dispatch event\n        break;\n      case err.includes(\"navigator.serial is undefined\"):\n        this.dispatch(\"serial:unsupported\", {});\n        // dispatch event\n        break;\n      default:\n        // unhandled error\n        console.error(error);\n        break;\n    }\n\n    this.dispatch(\"serial:error\", error);\n  }\n\n  #appendBuffer(arraybuffer: Uint8Array | ArrayBuffer | null): void {\n    if (arraybuffer) {\n      const incoming: Uint8Array = this.__internal__.serial.response.buffer;\n      const tmp: Uint8Array = new Uint8Array(incoming.length + arraybuffer.byteLength);\n      tmp.set(incoming, 0);\n      tmp.set(new Uint8Array(arraybuffer), incoming.length);\n      this.__internal__.serial.response.buffer = tmp;\n    }\n  }\n\n  async #transformStreamLoop(): Promise<void> {\n    if (this.__internal__.serial.time_until_send_bytes) {\n      clearTimeout(this.__internal__.serial.time_until_send_bytes);\n      this.__internal__.serial.time_until_send_bytes = 0;\n    }\n\n    if (this.__internal__.serial.response.buffer) {\n      this.#serialGetResponse(this.__internal__.serial.response.buffer);\n    }\n    this.__internal__.serial.response.buffer = new Uint8Array(0);\n  }\n\n  async #freeSerialLoop(): Promise<void> {\n    if (this.__internal__.serial.time_until_send_bytes) {\n      clearTimeout(this.__internal__.serial.time_until_send_bytes);\n      this.__internal__.serial.time_until_send_bytes = 0;\n    }\n\n    this.__internal__.serial.time_until_send_bytes = setTimeout((): void => {\n      if (this.__internal__.serial.response.buffer) {\n        this.#serialGetResponse(this.__internal__.serial.response.buffer);\n      }\n\n      this.__internal__.serial.response.buffer = new Uint8Array(0);\n    }, this.__internal__.serial.free_timeout_ms || 50);\n  }\n\n  async #slicedSerialLoop(): Promise<void> {\n    const expectedLength = this.__internal__.serial.response.length;\n    let buffer = this.__internal__.serial.response.buffer;\n\n    if (this.__internal__.serial.time_until_send_bytes) {\n      clearTimeout(this.__internal__.serial.time_until_send_bytes);\n      this.__internal__.serial.time_until_send_bytes = 0;\n    }\n\n    if (expectedLength === null || !buffer || buffer.length === 0) return;\n\n    while (buffer.length >= expectedLength) {\n      const message = buffer.slice(0, expectedLength);\n      this.#serialGetResponse(message);\n\n      buffer = buffer.slice(expectedLength);\n    }\n    this.__internal__.serial.response.buffer = buffer;\n\n    if (buffer.length > 0) {\n      this.__internal__.serial.time_until_send_bytes = setTimeout((): void => {\n        this.#serialGetResponse(this.__internal__.serial.response.buffer, true);\n      }, this.__internal__.serial.free_timeout_ms || 50);\n    }\n  }\n\n  async #delimitedSerialLoop(): Promise<void> {\n    const {\n      limiter,\n      prefixLimiter = false,\n      sufixLimiter = true,\n    }: {\n      limiter: string | RegExp | null;\n      prefixLimiter?: boolean;\n      sufixLimiter?: boolean;\n    } = this.__internal__.serial.response;\n\n    if (!limiter) {\n      throw new Error(\"No limiter defined for delimited serial response\");\n    }\n\n    const buffer = this.__internal__.serial.response.buffer;\n\n    if (!limiter || !buffer || buffer.length === 0) return;\n\n    if (this.__internal__.serial.time_until_send_bytes) {\n      clearTimeout(this.__internal__.serial.time_until_send_bytes);\n      this.__internal__.serial.time_until_send_bytes = 0;\n    }\n\n    const decoder = new TextDecoder();\n    let decoded = decoder.decode(buffer);\n    const messages: Uint8Array[] = [];\n\n    if (typeof limiter === \"string\") {\n      let pattern: RegExp;\n      if (prefixLimiter && sufixLimiter) {\n        pattern = new RegExp(`${limiter}([^${limiter}]+)${limiter}`, \"g\");\n      } else if (prefixLimiter) {\n        pattern = new RegExp(`${limiter}([^${limiter}]*)`, \"g\");\n      } else if (sufixLimiter) {\n        pattern = new RegExp(`([^${limiter}]+)${limiter}`, \"g\");\n      } else {\n        return;\n      }\n\n      let match;\n      let lastIndex = 0;\n      while ((match = pattern.exec(decoded)) !== null) {\n        messages.push(new TextEncoder().encode(match[1]));\n        lastIndex = pattern.lastIndex;\n      }\n\n      decoded = decoded.slice(lastIndex);\n    } else if (limiter instanceof RegExp) {\n      let match;\n      let lastIndex = 0;\n      if (prefixLimiter && sufixLimiter) {\n        const pattern = new RegExp(`${limiter.source}(.*?)${limiter.source}`, \"g\");\n        while ((match = pattern.exec(decoded)) !== null) {\n          messages.push(new TextEncoder().encode(match[1]));\n          lastIndex = pattern.lastIndex;\n        }\n      } else if (sufixLimiter) {\n        while ((match = limiter.exec(decoded)) !== null) {\n          const end = match.index;\n          const chunk = decoded.slice(lastIndex, end);\n          messages.push(new TextEncoder().encode(chunk));\n          lastIndex = limiter.lastIndex;\n        }\n      } else if (prefixLimiter) {\n        const parts = decoded.split(limiter);\n        parts.shift();\n        for (const part of parts) {\n          messages.push(new TextEncoder().encode(part));\n        }\n        decoded = \"\";\n      }\n\n      decoded = decoded.slice(lastIndex);\n    }\n\n    for (const msg of messages) {\n      this.#serialGetResponse(msg);\n    }\n\n    const leftoverBytes = new TextEncoder().encode(decoded);\n    this.__internal__.serial.response.buffer = leftoverBytes;\n\n    if (leftoverBytes.length > 0) {\n      this.__internal__.serial.time_until_send_bytes = setTimeout((): void => {\n        this.#serialGetResponse(this.__internal__.serial.response.buffer, true);\n        this.__internal__.serial.response.buffer = new Uint8Array(0);\n      }, this.__internal__.serial.free_timeout_ms ?? 50);\n    }\n  }\n\n  async #readSerialLoop(): Promise<void> {\n    const port: SerialPort | null = this.__internal__.serial.port;\n    if (!port || !port.readable) throw new Error(\"Port is not readable\");\n\n    const parser = this.__internal__.serial.transformStream ? this.__internal__.serial.transformStream : null;\n    const reader: ReadableStreamDefaultReader<Uint8Array> = parser\n      ? port.readable.pipeThrough(parser).getReader()\n      : port.readable.getReader();\n    //const reader: ReadableStreamDefaultReader<Uint8Array> = port.readable.getReader();\n\n    this.__internal__.serial.reader = reader;\n\n    try {\n      while (this.__internal__.serial.keep_reading) {\n        const { value, done } = await reader.read();\n        if (done) break;\n\n        this.#appendBuffer(value);\n\n        if (this.__internal__.serial.transformStream) {\n          await this.#transformStreamLoop();\n        } else if (this.__internal__.serial.response.delimited) {\n          await this.#delimitedSerialLoop();\n        } else if (this.__internal__.serial.response.length === null) {\n          await this.#freeSerialLoop();\n        } else {\n          await this.#slicedSerialLoop();\n        }\n      }\n    } catch (err: unknown) {\n      this.serialErrors(err);\n    } finally {\n      reader.releaseLock();\n      this.__internal__.serial.keep_reading = true;\n\n      if (this.__internal__.serial.port) {\n        await this.__internal__.serial.port.close();\n      }\n    }\n  }\n\n  #connectingChange(value: boolean): void {\n    if (value === this.__internal__.serial.connecting) return;\n\n    this.__internal__.serial.connecting = value;\n    this.dispatch(\"serial:connecting\", { active: value });\n    this.dispatch(\"internal:connecting\", { active: value });\n  }\n\n  public async serialConnect(): Promise<void> {\n    try {\n      this.#connectingChange(true);\n\n      if (this.useSocket) {\n        Socket.prepare();\n        this.__internal__.serial.last_action = \"connect\";\n        this.__internal__.timeout.until_response = setTimeout(async (): Promise<void> => {\n          await this.timeout(this.__internal__.serial.bytes_connection ?? [], \"connection:start\");\n        }, this.__internal__.time.response_connection);\n        if (Socket.isDisconnected()) {\n          return;\n        }\n        Socket.connectDevice(this.configDeviceSocket);\n        this.dispatch(\"serial:sent\", {\n          action: \"connect\",\n          bytes: this.__internal__.serial.bytes_connection,\n        });\n      } else {\n        const ports: SerialPort[] = await this.#serialPortsFiltered();\n        if (ports.length > 0) {\n          await this.serialPortsSaved(ports);\n        } else {\n          const filters: SerialPortFilter[] = this.serialFilters;\n          this.__internal__.serial.port = await navigator.serial.requestPort({\n            filters,\n          });\n        }\n\n        const port: SerialPort | null = this.__internal__.serial.port;\n        if (!port) {\n          throw new Error(\"No port selected by the user\");\n        }\n        await port.open(this.serialConfigPort);\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const this1: this = this;\n        port.onconnect = (event: Event): void => {\n          // console.log(event);\n          this1.dispatch(\"serial:connected\", event);\n          this1.#connectingChange(false);\n          Devices.$dispatchChange(this);\n          if (this1.__internal__.serial.queue.length > 0) {\n            this1.dispatch(\"internal:queue\", {});\n          } else {\n            this1.__internal__.serial.running_queue = false;\n          }\n        };\n        port.ondisconnect = async (): Promise<void> => {\n          await this1.disconnect();\n        };\n\n        await wait(this.__internal__.serial.delay_first_connection);\n\n        this.__internal__.timeout.until_response = setTimeout(async (): Promise<void> => {\n          await this1.timeout(this1.__internal__.serial.bytes_connection ?? [], \"connection:start\");\n        }, this.__internal__.time.response_connection);\n\n        this.__internal__.serial.last_action = \"connect\";\n        await this.#serialWrite(this.__internal__.serial.bytes_connection ?? []);\n\n        this.dispatch(\"serial:sent\", {\n          action: \"connect\",\n          bytes: this.__internal__.serial.bytes_connection,\n        });\n\n        if (this.__internal__.auto_response) {\n          this.#serialGetResponse(this.__internal__.serial.auto_response);\n        }\n        await this.#readSerialLoop();\n      }\n    } catch (e: unknown) {\n      this.#connectingChange(false);\n      this.serialErrors(e);\n    }\n  }\n\n  async #forget(): Promise<boolean> {\n    if (typeof window === \"undefined\") return false;\n\n    if (\"serial\" in navigator && \"forget\" in SerialPort.prototype && this.__internal__.serial.port) {\n      await this.__internal__.serial.port.forget();\n      return true;\n    }\n    return false;\n  }\n\n  public async serialForget(): Promise<boolean> {\n    return await this.#forget();\n  }\n\n  public decToHex(dec: number | string): string {\n    if (typeof dec === \"string\") {\n      dec = parseInt(dec, 10);\n    }\n    return dec.toString(16);\n  }\n\n  public hexToDec(hex: string): number {\n    return parseInt(hex, 16);\n  }\n\n  public hexMaker(val = \"00\", min = 2): string {\n    return val.toString().padStart(min, \"0\").toLowerCase();\n  }\n\n  public add0x(bytes: string[]): string[] {\n    const new_bytes: string[] = [];\n    bytes.forEach((value: string, index: number): void => {\n      new_bytes[index] = \"0x\" + value;\n    });\n    return new_bytes;\n  }\n\n  public bytesToHex(bytes: string[]): string[] {\n    return this.add0x(Array.from(bytes, (byte: string): string => this.hexMaker(byte)));\n  }\n\n  #registerDefaultListeners(): void {\n    const availableListeners: string[] = [\n      \"serial:connected\",\n      \"serial:connecting\",\n      \"serial:reconnect\",\n      \"serial:timeout\",\n      \"serial:disconnected\",\n      \"serial:sent\",\n      \"serial:soft-reload\",\n      \"serial:message\",\n      \"serial:corrupt-message\",\n      \"unknown\",\n      \"serial:need-permission\",\n      \"serial:lost\",\n      \"serial:unsupported\",\n      \"serial:error\",\n      \"debug\",\n    ];\n\n    availableListeners.forEach((event: string): void => {\n      this.serialRegisterAvailableListener(event);\n    });\n  }\n\n  #internalEvents(): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const this1: this = this;\n    this.on(\"internal:queue\", async (): Promise<void> => {\n      await this1.#runQueue();\n    });\n\n    const onSerialSocketDisconnect = (): void => {\n      if (this1.isConnected) {\n        this1.#disconnected({ error: \"Socket disconnected.\" });\n      }\n    };\n    const onSerialSocketConnect = (): void => {\n      if (this1.isDisconnected && !this1.isConnecting) {\n        this1.serialConnect().catch((): void => {});\n      }\n    };\n    if (this.useSocket) {\n      window.addEventListener(\"serial:socket:disconnected\", onSerialSocketDisconnect);\n      window.addEventListener(\"serial:socket:connected\", onSerialSocketConnect);\n    }\n\n    this.#browserEvents();\n  }\n\n  #browserEvents(): void {\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const this1: this = this;\n    navigator.serial.addEventListener(\"connect\", async (): Promise<void> => {\n      if (!this1.isDisconnected) return;\n      await this1.serialConnect().catch((): void => {});\n    });\n  }\n\n  async #runQueue(): Promise<void> {\n    if (this.useSocket && Socket.isDisconnected()) {\n      // socket disconnected, by default socket.io will try to reconnect\n      // just wait for reconnection, until then, do not process the queue\n      // but keep stop the queue processing, will start when socket reconnects and\n      // properly emits the 'serial:socket:connected' event to connect again the device\n      // then the queue will be processed again\n      return;\n    }\n    if (!this.#checkIfPortIsOpen(this.__internal__.serial.port)) {\n      this.#disconnected({ error: \"Port is closed, not readable or writable.\" });\n      await this.serialConnect();\n      return;\n    }\n\n    // check if something is waiting for a response, when response arrives, the queue will be processed\n    if (this.__internal__.timeout.until_response) return;\n\n    if (this.__internal__.serial.queue.length === 0) {\n      this.__internal__.serial.running_queue = false;\n      return;\n    }\n    this.__internal__.serial.running_queue = true;\n\n    // first element in queue\n    const first: QueueData = this.__internal__.serial.queue[0];\n    let limit_response: number = this.__internal__.time.response_general;\n    if (first.action === \"connect\") {\n      limit_response = this.__internal__.time.response_connection;\n    }\n\n    this.__internal__.timeout.until_response = setTimeout(async (): Promise<void> => {\n      await this.timeout(first.bytes, first.action);\n    }, limit_response);\n\n    this.__internal__.serial.last_action = first.action ?? \"unknown\";\n    await this.#serialWrite(first.bytes);\n\n    this.dispatch(\"serial:sent\", {\n      action: first.action,\n      bytes: first.bytes,\n    });\n\n    if (this.__internal__.auto_response) {\n      let bytes: Uint8Array = new Uint8Array(0);\n      try {\n        bytes = this.validateBytes(this.__internal__.serial.auto_response);\n      } catch (e: unknown) {\n        this.serialErrors(e);\n      }\n\n      this.#serialGetResponse(bytes);\n    }\n    const copy_queue: QueueData[] = [...this.__internal__.serial.queue];\n    this.__internal__.serial.queue = copy_queue.splice(1);\n\n    if (this.__internal__.serial.queue.length > 0) {\n      this.__internal__.serial.running_queue = true;\n      //this.dispatch(\"internal:queue\", {});\n    }\n  }\n\n  public validateBytes(data: string | Uint8Array | Array<string> | Array<number>): Uint8Array {\n    let bytes: Uint8Array = new Uint8Array(0);\n    if (data instanceof Uint8Array) {\n      bytes = data;\n    } else if (typeof data === \"string\") {\n      bytes = this.parseStringToTextEncoder(data);\n    } else if (Array.isArray(data) && typeof data[0] === \"string\") {\n      bytes = this.stringArrayToUint8Array(data as string[]);\n    } else if (Array.isArray(data) && typeof data[0] === \"number\") {\n      bytes = new Uint8Array(data as unknown as number[]);\n    } else {\n      throw new Error(\"Invalid data type\");\n    }\n    return bytes;\n  }\n\n  public async appendToQueue(arr: string | Uint8Array | string[] | number[], action: string): Promise<void> {\n    const bytes: Uint8Array = this.validateBytes(arr);\n\n    if ([\"connect\", \"connection:start\"].includes(action)) {\n      if (this.__internal__.serial.connected) return;\n\n      // ignore queue because the connection is not established, so first message is connection\n      // queue will never send a message before connection is established\n\n      await this.serialConnect();\n      return;\n    }\n\n    this.__internal__.serial.queue.push({ bytes, action });\n    this.dispatch(\"internal:queue\", {});\n  }\n\n  #serialSetBytesConnection(no_device = 1): void {\n    this.__internal__.device_number = no_device;\n    if (this.__internal__.bypassSerialBytesConnection) return;\n    this.__internal__.serial.bytes_connection = this.serialSetConnectionConstant(no_device);\n  }\n\n  public serialSetConnectionConstant(listen_on_port = 1): string | Uint8Array | string[] | number[] | null {\n    if (this.__internal__.bypassSerialBytesConnection) return this.__internal__.serial.bytes_connection;\n\n    // console.warn(\"wtf?\", this.bypassSerialBytesConnection);\n\n    throw new Error(`Method not implemented 'serialSetConnectionConstant' to listen on channel ${listen_on_port}`);\n    // ... implement in subclass\n    // return [];\n  }\n\n  public serialMessage(code: string[] | Uint8Array<ArrayBufferLike> | string | ArrayBuffer): void {\n    // this.dispatch('serial:message', code);\n    // ... implement in subclass\n    console.log(code);\n    this.dispatch(\"serial:message\", { code: code });\n    throw new Error(\"Method not implemented 'serialMessage'\");\n  }\n\n  public serialCorruptMessage(code: Uint8Array | number[] | string[] | never | null | string | ArrayBuffer): void {\n    // ... implement in subclass\n    console.log(code);\n    this.dispatch(\"serial:corrupt-message\", { code });\n    throw new Error(\"Method not implemented 'serialCorruptMessage'\");\n  }\n\n  #clearLastError(): void {\n    this.__internal__.last_error = {\n      message: null,\n      action: null,\n      code: null,\n      no_code: 0,\n    };\n  }\n\n  public clearSerialQueue(): void {\n    this.__internal__.serial.queue = [];\n  }\n\n  public sumHex(arr: string[]): string {\n    let sum: number = 0;\n    arr.forEach((value: string): void => {\n      sum += parseInt(value, 16);\n    });\n    return sum.toString(16);\n  }\n\n  public toString(): string {\n    return JSON.stringify({\n      __class: this.typeDevice,\n      device_number: this.deviceNumber,\n      uuid: this.uuid,\n      connected: this.isConnected,\n      connection: this.__internal__.serial.bytes_connection,\n    });\n  }\n\n  public softReload(): void {\n    this.#clearLastError();\n    this.dispatch(\"serial:soft-reload\", {});\n  }\n\n  public async sendConnect(): Promise<void> {\n    if (!this.__internal__.serial.bytes_connection) {\n      throw new Error(\"No connection bytes defined\");\n    }\n    await this.appendToQueue(this.__internal__.serial.bytes_connection, \"connect\");\n  }\n\n  public async sendCustomCode({ code = [] }: CustomCode = { code: [] }): Promise<void> {\n    if (!code) {\n      throw new Error(\"No data to send\");\n    }\n\n    if (this.__internal__.bypassSerialBytesConnection) {\n      this.__internal__.serial.bytes_connection = this.validateBytes(code);\n    }\n\n    await this.appendToQueue(code, \"custom\");\n  }\n\n  public stringToArrayHex(string: string): string[] {\n    return Array.from(string).map((char: string): string => char.charCodeAt(0).toString(16));\n  }\n\n  public stringToArrayBuffer(string: string, end: string = \"\\n\"): ArrayBufferLike {\n    return this.parseStringToTextEncoder(string, end).buffer;\n  }\n\n  public parseStringToTextEncoder(string: string = \"\", end: string = \"\\n\"): Uint8Array {\n    const encoder = new TextEncoder();\n    string += end; // to finish the command\n    return encoder.encode(string);\n  }\n\n  public parseStringToBytes(string: string = \"\", end: string = \"\\n\"): string[] {\n    const encoded: Uint8Array = this.parseStringToTextEncoder(string, end);\n    return Array.from(encoded).map((byte: number): string => byte.toString(16));\n  }\n\n  public parseUint8ToHex(array: Uint8Array): string[] {\n    return Array.from(array).map((byte: number): string => byte.toString(16).padStart(2, \"0\").toLowerCase());\n  }\n\n  public parseHexToUint8(array: string[]): Uint8Array {\n    return new Uint8Array(array.map((hexString: string): number => parseInt(hexString, 16)));\n  }\n\n  public stringArrayToUint8Array(strings: string[]): Uint8Array {\n    const bytes: number[] = [];\n    if (typeof strings === \"string\") {\n      return this.parseStringToTextEncoder(strings).buffer as unknown as Uint8Array;\n    }\n    strings.forEach((str: string): void => {\n      const hex = str.replace(\"0x\", \"\");\n      bytes.push(parseInt(hex, 16));\n    });\n\n    return new Uint8Array(bytes);\n  }\n\n  public parseUint8ArrayToString(array: Uint8Array | string[]): string {\n    let arrayUint8: Uint8Array = new Uint8Array(0);\n    if (array instanceof Uint8Array) {\n      arrayUint8 = array;\n    } else {\n      arrayUint8 = this.stringArrayToUint8Array(array as string[]);\n    }\n\n    array = this.parseUint8ToHex(arrayUint8);\n    const byteArray: number[] = array.map((hexString: string): number => parseInt(hexString, 16));\n    if (this.__internal__.serial.response.replacer) {\n      return String.fromCharCode(...byteArray).replace(this.__internal__.serial.response.replacer, \"\");\n    }\n    return String.fromCharCode(...byteArray);\n  }\n\n  public hexToAscii(hex: string | number): string {\n    const hexString: string = hex.toString();\n    let asciiString: string = \"\";\n    for (let i: number = 0; i < hexString.length; i += 2) {\n      asciiString += String.fromCharCode(parseInt(hexString.substring(i, 2), 16));\n    }\n    return asciiString;\n  }\n\n  public asciiToHex(asciiString: string): string {\n    const hexArray: string[] = [];\n    for (let i: number = 0, length: number = asciiString.length; i < length; i++) {\n      const hex: string = Number(asciiString.charCodeAt(i)).toString(16);\n      hexArray.push(hex);\n    }\n    return hexArray.join(\"\");\n  }\n\n  public $checkAndDispatchConnection(): boolean {\n    return this.isConnected;\n  }\n}\n","/**\n * Custom error codes for serial communication errors\n */\nexport enum SerialErrorCode {\n  CONNECTION_FAILED = \"CONNECTION_FAILED\",\n  DISCONNECTION_FAILED = \"DISCONNECTION_FAILED\",\n  WRITE_FAILED = \"WRITE_FAILED\",\n  READ_FAILED = \"READ_FAILED\",\n  TIMEOUT = \"TIMEOUT\",\n  PORT_NOT_FOUND = \"PORT_NOT_FOUND\",\n  PERMISSION_DENIED = \"PERMISSION_DENIED\",\n  DEVICE_NOT_SUPPORTED = \"DEVICE_NOT_SUPPORTED\",\n  INVALID_CONFIGURATION = \"INVALID_CONFIGURATION\",\n  SOCKET_ERROR = \"SOCKET_ERROR\",\n  UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n}\n\n/**\n * Custom error class for WebSerial operations\n * Provides structured error information with codes and context\n * @extends Error\n */\nexport class SerialError extends Error {\n  /**\n   * Error code identifying the type of error\n   */\n  public readonly code: SerialErrorCode;\n\n  /**\n   * Additional context about the error\n   */\n  public readonly context?: Record<string, unknown>;\n\n  /**\n   * Timestamp when the error occurred\n   */\n  public readonly timestamp: Date;\n\n  /**\n   * Creates a new SerialError\n   * @param message - Human-readable error message\n   * @param code - Error code from SerialErrorCode enum\n   * @param context - Additional context information\n   * @example\n   * ```typescript\n   * throw new SerialError(\n   *   'Failed to connect to device',\n   *   SerialErrorCode.CONNECTION_FAILED,\n   *   { port: 'COM3', baudRate: 9600 }\n   * );\n   * ```\n   */\n  constructor(\n    message: string,\n    code: SerialErrorCode = SerialErrorCode.UNKNOWN_ERROR,\n    context?: Record<string, unknown>,\n  ) {\n    super(message);\n    this.name = \"SerialError\";\n    this.code = code;\n    this.context = context;\n    this.timestamp = new Date();\n\n    // Maintains proper stack trace for where our error was thrown (only available on V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SerialError);\n    }\n  }\n\n  /**\n   * Returns a JSON representation of the error\n   * @returns Serialized error object\n   */\n  toJSON(): Record<string, unknown> {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      context: this.context,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n\n  /**\n   * Returns a formatted string representation of the error\n   * @returns Formatted error string\n   */\n  toString(): string {\n    const contextStr = this.context ? ` | Context: ${JSON.stringify(this.context)}` : \"\";\n    return `${this.name} [${this.code}]: ${this.message}${contextStr}`;\n  }\n}\n"],"names":["SerialEvent","type","options","Dispatcher","data","event","ms","this1","callback","listener","l","key","Devices","device","error","id","device_number","devices","wait","resolve","MySocket","#uri","#options","#socket","#connected","#hasInstance","#boundedFun","uri","url","io","config","Socket","defaultConfigPort","Core","#boundFinishConnecting","filters","config_port","no_device","device_listen_on_channel","bypassSerialBytesConnection","socket","transformStream","#serialSetBytesConnection","#registerDefaultListeners","#internalEvents","channel","value","prevConnected","connected","#checkIfPortIsOpen","#disconnected","#connectingChange","limiter","length","bytes","path","vendorId","productId","string","port","detail","#onFinishConnecting","auxPrevConnected","#serialGetResponse","reject","interval","reader","output_stream","err","#serialSocketWrite","#serialWrite","#waitForCTS","writer","timeoutMs","start","clearToSend","code","corrupt","str","splited","s","arraybuffer","#serialPortsFiltered","ports","info","filter","aux","#appendBuffer","incoming","tmp","#transformStreamLoop","#freeSerialLoop","#slicedSerialLoop","expectedLength","buffer","message","#delimitedSerialLoop","prefixLimiter","sufixLimiter","decoded","messages","pattern","match","lastIndex","end","chunk","parts","part","msg","leftoverBytes","#readSerialLoop","parser","done","#forget","dec","hex","val","min","new_bytes","index","byte","#runQueue","onSerialSocketDisconnect","onSerialSocketConnect","#browserEvents","first","limit_response","e","copy_queue","arr","action","listen_on_port","#clearLastError","sum","char","encoder","encoded","array","hexString","strings","arrayUint8","byteArray","asciiString","hexArray","i","SerialErrorCode","SerialError","context","contextStr"],"mappings":";AAAO,MAAMA,UAAoB,YAAgD;AAAA,EAC/E,YAAYC,GAAcC,GAA0B;AAClD,UAAMD,GAAMC,CAAO;AAAA,EACrB;AACF;ACuBO,MAAMC,UAAmB,YAAmC;AAAA,EACjE,gBAA2B;AAAA,IACzB,OAAO;AAAA,EAAA;AAAA,EAET,YAAqB;AAAA,EAErB,yBAA0F,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWnF,SAASF,GAAcG,IAAiB,MAAM;AACnD,UAAMC,IAAQ,IAAIL,EAAYC,GAAM,EAAE,QAAQG,GAAM;AACpD,SAAK,cAAcC,CAAK,GACpB,KAAK,aACP,KAAK,cAAc,IAAIL,EAAY,SAAS,EAAE,QAAQ,EAAE,MAAAC,GAAM,MAAAG,EAAA,EAAK,CAAG,CAAC;AAAA,EAE3E;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYO,cAAcH,GAAcG,IAAO,MAAME,IAAK,KAAK;AAExD,UAAMC,IAAQ;AACd,eAAW,MAAM;AACf,MAAAA,EAAM,SAASN,GAAMG,CAAI;AAAA,IAC3B,GAAGE,CAAE;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaO,GAAGL,GAAcO,GAA8C;AACpE,IAAI,OAAO,KAAK,cAAcP,CAAI,IAAM,OAAe,CAAC,KAAK,cAAcA,CAAI,MAC7E,KAAK,cAAcA,CAAI,IAAI,KAG7B,KAAK,uBAAuB,KAAK,EAAE,KAAKA,GAAM,UAAAO,GAAU,GACxD,KAAK,iBAAiBP,GAAMO,CAAQ;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaO,IAAIP,GAAcO,GAA8C;AACrE,SAAK,yBAAyB,KAAK,uBAAuB,OAAO,CAACC,MACzD,EAAEA,EAAS,QAAQR,KAAQQ,EAAS,aAAaD,EACzD,GAED,KAAK,oBAAoBP,GAAMO,CAAQ;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gCAAgCP,GAAc;AACnD,IAAI,KAAK,cAAcA,CAAI,MAE3B,KAAK,cAAcA,CAAI,IAAI;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,IAAI,qBAAyC;AAE3C,WADa,OAAO,KAAK,KAAK,aAAa,EAAE,KAAA,EACjC,IAAI,CAACA,OACR;AAAA,MACL,MAAAA;AAAA,MACA,WAAW,KAAK,cAAcA,CAAI;AAAA,IAAA,EAErC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUO,qBAA2B;AAChC,eAAWQ,KAAY,KAAK;AAC1B,MAAI,CAAC,gBAAgB,EAAE,SAASA,EAAS,GAAG,MAE5C,KAAK,yBAAyB,KAAK,uBAAuB,OAAO,CAACC,MACzD,EAAEA,EAAE,QAAQD,EAAS,OAAOC,EAAE,aAAaD,EAAS,SAC5D,GACD,KAAK,oBAAoBA,EAAS,KAAKA,EAAS,QAAQ;AAE1D,eAAWE,KAAO,OAAO,KAAK,KAAK,aAAa;AAC9C,WAAK,cAAcA,CAAG,IAAI;AAAA,EAE9B;AACF;AChJO,MAAMC,UAAgBT,EAAW;AAAA,EACtC,OAAO;AAAA,EACP,OAAO,UAAoB,CAAA;AAAA,EAE3B,cAAc;AACZ,UAAA,GAEqC,CAAC,QAAQ,EAE3B,QAAQ,CAACE,MAAwB;AAClD,WAAK,gCAAgCA,CAAK;AAAA,IAC5C,CAAC;AAAA,EACH;AAAA,EAEA,OAAc,gBAAgBQ,IAAsB,MAAY;AAC9D,IAAIA,KACFA,EAAO,4BAAA,GAETD,EAAQ,SAAS,SAAS,UAAU,EAAE,SAASA,EAAQ,SAAS,YAAYC,GAAQ;AAAA,EACtF;AAAA,EAEA,OAAc,UAAUZ,GAAoB;AAC1C,UAAMa,IAAQ,IAAI,MAAA;AAClB,UAAAA,EAAM,UAAU,QAAQb,CAAI,qBAC5Ba,EAAM,OAAO,mBACPA;AAAA,EACR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAc,aAAab,GAAoB;AAC7C,IAAI,OAAOW,EAAQ,QAAQX,CAAI,IAAM,QACnCW,EAAQ,UAAU,EAAE,GAAGA,EAAQ,SAAS,CAACX,CAAI,GAAG,GAAC;AAAA,EAErD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,OAAc,IAAIY,GAAsB;AACtC,UAAMZ,IAAOY,EAAO;AACpB,IAAI,OAAOD,EAAQ,QAAQX,CAAI,IAAM,OACnCW,EAAQ,aAAaX,CAAI;AAG3B,UAAMc,IAAaF,EAAO;AAI1B,QAFI,OAAOD,EAAQ,QAAQX,CAAI,IAAM,OAAaW,EAAQ,UAAUX,CAAI,GAEpEW,EAAQ,QAAQX,CAAI,EAAEc,CAAE;AAC1B,YAAM,IAAI,MAAM,kBAAkBA,CAAE,iBAAiB;AAGvD,WAAAH,EAAQ,QAAQX,CAAI,EAAEc,CAAE,IAAIF,GAE5BD,EAAQ,gBAAgBC,CAAM,GACvB,OAAO,KAAKD,EAAQ,QAAQX,CAAI,CAAC,EAAE,QAAQc,CAAE;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,OAAc,IAAId,GAAcc,GAAkB;AAChD,WAAI,OAAOH,EAAQ,QAAQX,CAAI,IAAM,OACnCW,EAAQ,aAAaX,CAAI,GAGvB,OAAOW,EAAQ,QAAQX,CAAI,IAAM,OAAaW,EAAQ,UAAUX,CAAI,GAEjEW,EAAQ,QAAQX,CAAI,EAAEc,CAAE;AAAA,EACjC;AAAA,EAEA,OAAc,OAAOd,IAAsB,MAA0B;AACnE,WAAIA,MAAS,OAAaW,EAAQ,WAC9B,OAAOA,EAAQ,QAAQX,CAAI,IAAM,OAAaW,EAAQ,UAAUX,CAAI,GAEjEW,EAAQ,QAAQX,CAAI;AAAA,EAC7B;AAAA,EAEA,OAAc,UAAkB;AAI9B,WAD2B,OAAO,OAAOW,EAAQ,OAAO,EAErD,IAAI,CAACC,MACG,OAAO,OAAOA,CAAM,CAC5B,EACA,KAAA;AAAA,EACL;AAAA,EAEA,OAAc,YAAYZ,GAAce,GAAoC;AAC1E,WAAI,OAAOJ,EAAQ,QAAQX,CAAI,IAAM,OAAaW,EAAQ,UAAUX,CAAI,GAExD,OAAO,OAAOW,EAAQ,QAAQX,CAAI,CAAC,EACpC,KAAK,CAACY,MAAWA,EAAO,iBAAiBG,CAAa,KAAK;AAAA,EAC5E;AAAA,EAEA,OAAc,UAAUf,GAAce,IAAwB,GAAgB;AAC5E,WAAI,OAAOJ,EAAQ,QAAQX,CAAI,IAAM,OAAaW,EAAQ,UAAUX,CAAI,GAExD,OAAO,OAAOW,EAAQ,QAAQX,CAAI,CAAC,EACpC,KAAK,CAACY,MAAWA,EAAO,iBAAiBG,CAAa,KAAK;AAAA,EAC5E;AAAA,EAEA,aAAoB,eAAiC;AACnD,UAAMC,IAAkBL,EAAQ,QAAA;AAEhC,eAAWC,KAAUI;AACnB,MAAIJ,EAAO,eACX,MAAMA,EAAO,QAAA,EAAU,MAAM,QAAQ,IAAI;AAG3C,WAAO,QAAQ,QAAQD,EAAQ,gBAAA,CAAiB;AAAA,EAClD;AAAA,EAEA,aAAoB,gBAAkC;AACpD,UAAMK,IAAkBL,EAAQ,QAAA;AAEhC,eAAWC,KAAUI;AACnB,MAAIJ,EAAO,kBACX,MAAMA,EAAO,WAAA,EAAa,MAAM,QAAQ,IAAI;AAG9C,WAAO,QAAQ,QAAQD,EAAQ,mBAAA,CAAoB;AAAA,EACrD;AAAA,EAEA,aAAoB,kBAAoC;AACtD,UAAMK,IAAkBL,EAAQ,QAAA;AAEhC,eAAWC,KAAUI;AACnB,UAAI,CAACJ,EAAO,YAAa,QAAO,QAAQ,QAAQ,EAAK;AAGvD,WAAO,QAAQ,QAAQ,EAAI;AAAA,EAC7B;AAAA,EAEA,aAAoB,qBAAuC;AACzD,UAAMI,IAAkBL,EAAQ,QAAA;AAEhC,eAAWC,KAAUI;AACnB,UAAI,CAACJ,EAAO,eAAgB,QAAO,QAAQ,QAAQ,EAAK;AAG1D,WAAO,QAAQ,QAAQ,EAAI;AAAA,EAC7B;AAAA,EAEA,aAAoB,kBAAmC;AACrD,UAAMI,IAAkBL,EAAQ,QAAA;AAChC,WAAO,QAAQ,QAAQK,EAAQ,OAAO,CAACJ,MAA0BA,EAAO,WAAW,CAAC;AAAA,EACtF;AAAA,EAEA,aAAoB,qBAAsC;AACxD,UAAMI,IAAkBL,EAAQ,QAAA;AAChC,WAAO,QAAQ,QAAQK,EAAQ,OAAO,CAACJ,MAA0BA,EAAO,cAAc,CAAC;AAAA,EACzF;AACF;AAEKD,EAAQ,aACXA,EAAQ,WAAW,IAAIA,EAAA;AC/LlB,SAASM,EAAKZ,IAAa,KAAoB;AACpD,SAAO,IAAI;AAAA,IACT,CAACa,MAAmE,WAAW,MAAYA,EAAA,GAAWb,CAAE;AAAA,EAAA;AAE5G;ACYA,MAAMc,EAAS;AAAA,EACbC,KAAe;AAAA,EACfC,KAAoD;AAAA,IAClD,YAAY,CAAC,WAAW;AAAA,EAAA;AAAA,EAE1BC,KAAiC;AAAA,EACjCC,KAAsB;AAAA,EACtBC,KAAwB;AAAA,EAExBC;AAAA,EAEA,YAAYC,GAAczB,GAAmD;AAC3E,IAAIyB,MACF,KAAKN,KAAOM,IAEVzB,MACF,KAAKoB,KAAW,EAAE,GAAG,KAAKA,IAAU,GAAGpB,EAAA,IAGzC,KAAKwB,KAAc;AAAA,MACjB,YAAY,KAAK,WAAW,KAAK,IAAI;AAAA,MACrC,cAAc,MAAM;AAElB,aAAKF,KAAa,IAClB,OAAO,cAAc,IAAI,MAAM,4BAA4B,CAAC;AAAA,MAC9D;AAAA,MACA,WAAW,MAAM;AAEf,aAAKA,KAAa,IAClB,OAAO,cAAc,IAAI,MAAM,yBAAyB,CAAC;AAAA,MAC3D;AAAA,MACA,gBAAgB,CAACV,MAAU;AACzB,gBAAQ,MAAM,2BAA2BA,CAAK,GAC9C,KAAKU,KAAa,IAClB,OAAO,cAAc,IAAI,MAAM,4BAA4B,CAAC;AAAA,MAC9D;AAAA,IAAA;AAAA,EAEJ;AAAA,EAEA,IAAI,IAAIG,GAAa;AACnB,UAAMC,IAAM,IAAI,IAAID,CAAG;AAEvB,QAAI,CAAC,CAAC,SAAS,UAAU,OAAO,MAAM,EAAE,SAASC,EAAI,QAAQ;AAC3D,YAAM,IAAI,MAAM,yDAAyD;AAE3E,SAAKP,KAAOM;AAAA,EACd;AAAA,EAEA,IAAI,MAAc;AAChB,WAAO,KAAKN;AAAA,EACd;AAAA,EAEA,IAAI,QAAQnB,GAAkD;AAC5D,QAAI,OAAOA,KAAY;AACrB,YAAM,IAAI,MAAM,2BAA2B;AAE7C,SAAKoB,KAAWpB;AAAA,EAClB;AAAA,EAEA,IAAI,UAAmD;AACrD,WAAO,KAAKoB;AAAA,EACd;AAAA,EAEA,IAAI,WAA0B;AAC5B,WAAO,KAAKC,MAAW,KAAKA,GAAQ,KAAK,KAAKA,GAAQ,KAAK;AAAA,EAC7D;AAAA,EAEA,UAAUI,GAAczB,GAAyD;AAC/E,QAAI,KAAKuB;AACP,YAAM,IAAI,MAAM,2FAA2F;AAE7G,IAAIE,MACF,KAAK,MAAMA,IAETzB,MACF,KAAKoB,KAAW,EAAE,GAAG,KAAKA,IAAU,GAAGpB,EAAA;AAAA,EAE3C;AAAA,EAEA,aAAa;AACX,IAAI,KAAKqB,OACP,KAAKA,GAAQ,IAAI,YAAY,KAAKG,GAAY,UAAU,GACxD,KAAKH,GAAQ,IAAI,cAAc,KAAKG,GAAY,YAAY,GAC5D,KAAKH,GAAQ,IAAI,WAAW,KAAKG,GAAY,SAAS,GACtD,KAAKH,GAAQ,IAAI,iBAAiB,KAAKG,GAAY,cAAc,GAEjE,KAAKH,GAAQ,WAAA,GACb,KAAKA,KAAU,MACf,KAAKE,KAAe,KAEtB,KAAKD,KAAa;AAAA,EACpB;AAAA,EAEA,UAAU;AACR,IAAI,KAAKA,MAAc,KAAKC,OAE5B,KAAKF,KAAUM,EAAG,KAAKR,IAAM,KAAKC,EAAQ,GAE1C,KAAKG,KAAe,IAEpB,KAAKF,GAAQ,GAAG,cAAc,KAAKG,GAAY,YAAY,GAC3D,KAAKH,GAAQ,GAAG,YAAY,KAAKG,GAAY,UAAU,GACvD,KAAKH,GAAQ,GAAG,WAAW,KAAKG,GAAY,SAAS,GACrD,KAAKH,GAAQ,GAAG,iBAAiB,KAAKG,GAAY,cAAc;AAAA,EAClE;AAAA,EAEA,cAAcI,GAAsB;AAClC,QAAI,CAAC,KAAKP;AACR,YAAM,IAAI,MAAM,6CAA6C;AAE/D,SAAKA,GAAQ,KAAK,iBAAiB,EAAE,QAAAO,GAAQ;AAAA,EAC/C;AAAA,EAEA,iBAAiBA,GAAsB;AACrC,QAAI,CAAC,KAAKP;AACR,YAAM,IAAI,MAAM,6CAA6C;AAE/D,SAAKA,GAAQ,KAAK,oBAAoB,EAAE,QAAAO,GAAQ;AAAA,EAClD;AAAA,EAEA,uBAA6B;AAC3B,QAAI,CAAC,KAAKP;AACR,YAAM,IAAI,MAAM,6CAA6C;AAE/D,SAAKA,GAAQ,KAAK,eAAe;AAAA,EACnC;AAAA,EAEA,MAAMnB,GAAoB;AACxB,QAAI,CAAC,KAAKmB;AACR,YAAM,IAAI,MAAM,6CAA6C;AAE/D,SAAKA,GAAQ,KAAK,OAAOnB,CAAI;AAAA,EAC/B;AAAA,EAEA,WAAWA,GAAgC;AACzC,QAAIS,IAAsBD,EAAQ,IAAIR,EAAK,MAAMA,EAAK,IAAI;AAI1D,IAHKS,MACHA,IAASD,EAAQ,YAAYR,EAAK,MAAMA,EAAK,YAAY,IAEtDS,KAGLA,EAAO,eAAeT,CAAI;AAAA,EAC5B;AAAA,EAEA,cAAuB;AACrB,WAAO,KAAKoB;AAAA,EACd;AAAA,EAEA,iBAA0B;AACxB,WAAO,CAAC,KAAKA;AAAA,EACf;AACF;AAEO,MAAMO,IAAS,IAAIX,EAAA,GC1DpBY,IAAmC;AAAA,EACvC,UAAU;AAAA,EACV,UAAU;AAAA,EACV,UAAU;AAAA,EACV,QAAQ;AAAA,EACR,YAAY;AAAA,EACZ,aAAa;AACf;AA0IO,MAAMC,UAAa9B,EAA4B;AAAA,EAC1C,eAAyB;AAAA,IACjC,6BAA6B;AAAA,IAC7B,eAAe;AAAA,IACf,eAAe;AAAA,IACf,oBAAoB;AAAA,IACpB,YAAY;AAAA,MACV,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,IAAA;AAAA,IAEX,QAAQ;AAAA,MACN,iBAAiB;AAAA,MACjB,QAAQ;AAAA,MACR,UAAU;AAAA,QACR,MAAM;AAAA,QACN,UAAU;AAAA,QACV,WAAW;AAAA,QACX,QAAQ;AAAA,UACN,MAAM;AAAA,UACN,UAAU;AAAA,QAAA;AAAA,MACZ;AAAA,MAEF,gBAAgB;AAAA,MAChB,YAAY;AAAA,MACZ,WAAW;AAAA,MACX,MAAM;AAAA,MACN,aAAa;AAAA,MACb,UAAU;AAAA,QACR,QAAQ;AAAA,QACR,QAAQ,IAAI,WAAW,EAAE;AAAA,QACzB,IAAI;AAAA,QACJ,UAAU;AAAA,QACV,SAAS;AAAA,QACT,eAAe;AAAA,QACf,cAAc;AAAA,QACd,WAAW;AAAA,MAAA;AAAA,MAEb,QAAQ;AAAA,MACR,YAAY;AAAA,MACZ,aAAa;AAAA,MACb,cAAc;AAAA,MACd,eAAe;AAAA,MACf,cAAc;AAAA,MACd,uBAAuB;AAAA,MACvB,wBAAwB;AAAA,MACxB,kBAAkB;AAAA,MAClB,SAAS,CAAA;AAAA,MACT,aAAa6B;AAAA,MACb,OAAO,CAAA;AAAA,MACP,eAAe;AAAA,MACf,eAAe;AAAA,MACf,iBAAiB;AAAA;AAAA,MACjB,WAAW;AAAA;AAAA,IAAA;AAAA,IAEb,QAAQ;AAAA,MACN,MAAM;AAAA,MACN,IAAI,OAAO,OAAO,WAAA;AAAA,MAClB,gBAAgB;AAAA,IAAA;AAAA,IAElB,MAAM;AAAA,MACJ,qBAAqB;AAAA,MACrB,kBAAkB;AAAA,MAClB,kBAAkB;AAAA,IAAA;AAAA,IAEpB,SAAS;AAAA,MACP,gBAAgB;AAAA,IAAA;AAAA,IAElB,UAAU;AAAA,MACR,cAAc;AAAA,IAAA;AAAA,EAChB;AAAA,EAGFE,KAAoE;AAAA,EAEpE,YACE;AAAA,IACE,SAAAC,IAAU;AAAA,IACV,aAAAC,IAAcJ;AAAA,IACd,WAAAK,IAAY;AAAA,IACZ,0BAAAC,IAA2B;AAAA,IAC3B,6BAAAC,IAA8B;AAAA,IAC9B,QAAAC,IAAS;AAAA,IACT,iBAAAC,IAAkB;AAAA,EAAA,IACO;AAAA,IACzB,SAAS;AAAA,IACT,aAAaT;AAAA,IACb,WAAW;AAAA,IACX,0BAA0B;AAAA,IAC1B,6BAA6B;AAAA,IAC7B,QAAQ;AAAA,IACR,iBAAiB;AAAA,EAAA,GAEnB;AAGA,QAFA,MAAA,GAEI,EAAE,YAAY;AAChB,YAAM,IAAI,MAAM,0BAA0B;AAG5C,IAAIG,MACF,KAAK,gBAAgBA,IAGnBC,MACF,KAAK,mBAAmBA,IAGtBG,MACF,KAAK,aAAa,8BAA8BA,IAG9CF,KACF,KAAKK,GAA0BL,CAAS,GAGtCC,KAA4B,CAAC,UAAU,QAAQ,EAAE,SAAS,OAAOA,CAAwB,MAC3F,KAAK,kBAAkBA,IAGzB,KAAK,aAAa,OAAO,SAASE,GAClC,KAAK,aAAa,OAAO,kBAAkBC,GAE3C,KAAKE,GAAA,GACL,KAAKC,GAAA;AAAA,EACP;AAAA,EAEA,IAAI,gBAAgBC,GAA0B;AAI5C,QAHI,OAAOA,KAAY,aACrBA,IAAU,SAASA,CAAO,IAExB,MAAMA,CAAO,KAAKA,IAAU,KAAKA,IAAU;AAC7C,YAAM,IAAI,MAAM,qBAAqB;AAGvC,IADA,KAAK,aAAa,OAAO,iBAAiBA,GACtC,MAAK,aAAa,gCACtB,KAAK,aAAa,OAAO,mBAAmB,KAAK,4BAA4BA,CAAO;AAAA,EACtF;AAAA,EAEA,IAAI,aAA4B;AAC9B,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,kBAA0B;AAC5B,WAAO,KAAK,aAAa,OAAO,kBAAkB;AAAA,EACpD;AAAA,EAEA,IAAI,cAAcV,GAA6B;AAC7C,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,8CAA8C;AACpF,SAAK,aAAa,OAAO,UAAUA;AAAA,EACrC;AAAA,EAEA,IAAI,gBAAoC;AACtC,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,iBAAiBC,GAA4B;AAC/C,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,8CAA8C;AACpF,SAAK,aAAa,OAAO,cAAcA;AAAA,EACzC;AAAA,EAEA,IAAI,mBAAkC;AACpC,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,YAAqB;AACvB,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,UAAUU,GAAgB;AAC5B,SAAK,aAAa,OAAO,YAAYA;AAAA,EACvC;AAAA,EAEA,IAAI,cAAuB;AACzB,UAAMC,IAAgB,KAAK,aAAa,OAAO,WACzCC,IAAY,KAAKC,GAAmB,KAAK,aAAa,OAAO,IAAI;AACvE,WAAIF,KAAiB,CAACC,KACpB,KAAKE,GAAc,EAAE,OAAO,4CAAA,CAA6C,GAE3E,KAAK,aAAa,OAAO,YAAYF,GAC9B,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,eAAwB;AAC1B,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,iBAA0B;AAC5B,UAAMD,IAAgB,KAAK,aAAa,OAAO,WACzCC,IAAY,KAAKC,GAAmB,KAAK,aAAa,OAAO,IAAI;AACvE,WAAI,CAACF,KAAiBC,MACpB,KAAK,SAAS,kBAAkB,GAChC,KAAKG,GAAkB,EAAK,GAC5BvC,EAAQ,gBAAgB,IAAI,IAE9B,KAAK,aAAa,OAAO,YAAYoC,GAC9B,CAAC,KAAK,aAAa,OAAO;AAAA,EACnC;AAAA,EAEA,IAAI,eAAuB;AACzB,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,IAAI,OAAe;AACjB,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,aAAqB;AACvB,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,QAAqB;AACvB,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,oBAA6B;AAC/B,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,kBAAkBF,GAAgB;AACpC,QAAI,OAAOA,KAAU;AACnB,YAAM,IAAI,MAAM,qCAAqC;AAEvD,SAAK,aAAa,OAAO,SAAS,YAAYA;AAAA,EAChD;AAAA,EAEA,IAAI,wBAAiC;AACnC,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,sBAAsBA,GAAgB;AACxC,QAAI,OAAOA,KAAU;AACnB,YAAM,IAAI,MAAM,yCAAyC;AAE3D,SAAK,aAAa,OAAO,SAAS,gBAAgBA;AAAA,EACpD;AAAA,EAEA,IAAI,uBAAgC;AAClC,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,qBAAqBA,GAAgB;AACvC,QAAI,OAAOA,KAAU;AACnB,YAAM,IAAI,MAAM,wCAAwC;AAE1D,SAAK,aAAa,OAAO,SAAS,eAAeA;AAAA,EACnD;AAAA,EAEA,IAAI,kBAA0C;AAC5C,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,gBAAgBM,GAAiC;AACnD,QAAI,OAAOA,KAAY,YAAY,EAAEA,aAAmB;AACtD,YAAM,IAAI,MAAM,8CAA8C;AAGhE,SAAK,aAAa,OAAO,SAAS,UAAUA;AAAA,EAC9C;AAAA,EAEA,IAAI,oBAAmC;AACrC,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,kBAAkBC,GAAuB;AAC3C,QAAIA,MAAW,SAAS,OAAOA,KAAW,YAAYA,IAAS;AAC7D,YAAM,IAAI,MAAM,wCAAwC;AAE1D,SAAK,aAAa,OAAO,SAAS,SAASA;AAAA,EAC7C;AAAA,EAEA,IAAI,6BAAqC;AACvC,WAAO,KAAK,aAAa,OAAO,mBAAmB;AAAA,EACrD;AAAA,EAEA,IAAI,2BAA2BP,GAAe;AAC5C,QAAIA,MAAU,WAAc,OAAOA,KAAU,YAAYA,IAAQ;AAC/D,YAAM,IAAI,MAAM,oCAAoC;AAEtD,SAAK,aAAa,OAAO,kBAAkBA,KAAS;AAAA,EACtD;AAAA,EAEA,IAAI,8BAAuC;AACzC,WAAO,KAAK,aAAa;AAAA,EAC3B;AAAA,EAEA,IAAI,4BAA4BA,GAAgB;AAC9C,QAAI,OAAOA,KAAU;AACnB,YAAM,IAAI,MAAM,+CAA+C;AAEjE,SAAK,aAAa,8BAA8BA;AAAA,EAClD;AAAA,EAEA,IAAI,YAAqB;AACvB,WAAO,KAAK,aAAa,OAAO;AAAA,EAClC;AAAA,EAEA,IAAI,kBAA8B;AAChC,UAAMQ,IAAQ,KAAK,aAAa,OAAO;AAEvC,WAAIA,aAAiB,aACZA,IAGL,OAAOA,KAAU,WACZ,KAAK,wBAAwB,KAAK,mBAAmBA,GAAO,EAAE,CAAC,IAGpE,MAAM,QAAQA,CAAK,KAAK,OAAOA,EAAM,CAAC,KAAM,WACvC,KAAK,wBAAwBA,CAAiB,IAGnD,MAAM,QAAQA,CAAK,KAAK,OAAOA,EAAM,CAAC,KAAM,WACvC,IAAI,WAAWA,CAAiB,IAGlC,IAAI,WAAW,EAAE;AAAA,EAC1B;AAAA,EAEA,IAAI,SAASC,GAAqB;AAChC,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,yCAAyC;AAC/E,QAAI,OAAOA,KAAS,YAAYA,MAAS;AACvC,YAAM,IAAI,UAAU,iCAAiC;AAEvD,SAAK,aAAa,OAAO,SAAS,OAAOA;AAAA,EAC3C;AAAA,EAEA,IAAI,WAA0B;AAC5B,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,aAAaC,GAAkC;AACjD,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,6CAA6C;AACnF,QAAI,OAAOA,KAAa,YAAY,OAAOA,KAAa,YAAYA,MAAa;AAC/E,YAAM,IAAI,UAAU,2CAA2C;AAEjE,SAAK,aAAa,OAAO,SAAS,WAAWA;AAAA,EAC/C;AAAA,EAEA,IAAI,eAAuC;AACzC,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,cAAcC,GAAmC;AACnD,QAAI,KAAK,YAAa,OAAM,IAAI,MAAM,8CAA8C;AACpF,QAAI,OAAOA,KAAc,YAAY,OAAOA,KAAc,YAAYA,MAAc;AAClF,YAAM,IAAI,UAAU,4CAA4C;AAElE,SAAK,aAAa,OAAO,SAAS,YAAYA;AAAA,EAChD;AAAA,EAEA,IAAI,gBAAwC;AAC1C,WAAO,KAAK,aAAa,OAAO,SAAS;AAAA,EAC3C;AAAA,EAEA,IAAI,iBAAiBC,GAA8C;AACjE,QAAI,CAAC,eAAe,oBAAoB,EAAE,SAASA,CAAM;AACvD,YAAM,IAAI,UAAU,iFAAiF;AAEvG,SAAK,aAAa,OAAO,SAAS,OAAO,OAAOA;AAAA,EAClD;AAAA,EAEA,IAAI,mBAAyD;AAC3D,WAAO,KAAK,aAAa,OAAO,SAAS,OAAO;AAAA,EAClD;AAAA,EAEA,IAAI,yBAAyBZ,GAAe;AAC1C,QAAI,OAAOA,KAAU,YAAYA,IAAQ;AACvC,YAAM,IAAI,UAAU,oCAAoC;AAG1D,SAAK,aAAa,OAAO,SAAS,OAAO,WAAWA;AAAA,EACtD;AAAA,EAEA,IAAI,2BAAmC;AACrC,WAAO,KAAK,aAAa,OAAO,SAAS,OAAO,YAAY;AAAA,EAC9D;AAAA,EAEA,IAAI,uBAAuBA,GAAe;AACxC,QAAI,OAAOA,KAAU,YAAYA,IAAQ;AACvC,YAAM,IAAI,UAAU,0CAA0C;AAEhE,SAAK,aAAa,OAAO,SAAS,OAAO,SAASA;AAAA,EACpD;AAAA,EAEA,IAAI,yBAAiC;AACnC,WAAO,KAAK,aAAa,OAAO,SAAS,OAAO,UAAU;AAAA,EAC5D;AAAA,EAEA,IAAI,kBAAkB;AACpB,WAAI,KAAK,qBAAqB,gBACrB;AAAA,MACL,MAAM,KAAK;AAAA,MACX,QAAQ,KAAK;AAAA,IAAA,IAGV;AAAA,MACL,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,IAAA;AAAA,EAEnB;AAAA,EAEA,IAAI,qBAA6B;AAC/B,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,cAAc,KAAK;AAAA,MACnB,iBAAiB,MAAM,KAAK,KAAK,eAAe;AAAA,MAChD,QAAQ;AAAA,QACN,UAAU,KAAK,aAAa,OAAO,YAAY;AAAA,QAC/C,UAAU,KAAK,aAAa,OAAO,YAAY;AAAA,QAC/C,UAAU,KAAK,aAAa,OAAO,YAAY;AAAA,QAC/C,QAAQ,KAAK,aAAa,OAAO,YAAY;AAAA,QAC7C,YAAY,KAAK,aAAa,OAAO,YAAY;AAAA,QACjD,aAAa,KAAK,aAAa,OAAO,YAAY;AAAA,MAAA;AAAA,MAEpD,MAAM;AAAA,QACJ,UAAU,KAAK;AAAA;AAAA,QACf,WAAW,KAAK;AAAA;AAAA,QAChB,UAAU,KAAK;AAAA;AAAA,MAAA;AAAA,MAEjB,UAAU;AAAA,QACR,WAAW,KAAK,aAAa;AAAA;AAAA,QAC7B,cAAc,KAAK,aAAa,OAAO;AAAA;AAAA,QACvC,QAAQ,KAAK;AAAA,QACb,SAAS;AAAA,UACP,SAAS,KAAK,aAAa,KAAK;AAAA,UAChC,SAAS,KAAK,aAAa,KAAK;AAAA,UAChC,YAAY,KAAK,aAAa,KAAK;AAAA,QAAA;AAAA,MACrC;AAAA,IACF;AAAA,EAEJ;AAAA,EAEAG,GAAmBU,GAAkC;AACnD,WAAI,KAAK,YACA,KAAK,aAAa,OAAO,aAAa5B,EAAO,YAAA,IAG/C,CAAC,EAAE4B,KAAQA,EAAK,YAAYA,EAAK;AAAA,EAC1C;AAAA,EAEA,MAAa,QAAQL,GAA4DjD,GAA8B;AAC7G,SAAK,aAAa,WAAW,UAAU,iCACvC,KAAK,aAAa,WAAW,SAASA,GACtC,KAAK,aAAa,WAAW,OAAOiD,GAChC,KAAK,aAAa,QAAQ,mBAC5B,aAAa,KAAK,aAAa,QAAQ,cAAc,GACrD,KAAK,aAAa,QAAQ,iBAAiB,IAEzCjD,MAAU,aACZ,KAAK,aAAa,OAAO,YAAY,IACrC,KAAK,SAAS,oBAAoB,EAAE,GACpCO,EAAQ,gBAAgB,IAAI,KACnBP,MAAU,uBACnB,MAAM,KAAK,iBAAA,GACX,KAAK,aAAa,OAAO,YAAY,IACrC,KAAK,aAAa,sBAAsB,GACxCO,EAAQ,gBAAgB,IAAI,GAC5B,MAAM,KAAK,cAAA,IAGT,KAAK,aAAa,OAAO,MAAM,SAAS,KAC1C,KAAK,SAAS,kBAAkB,EAAE,GAGpC,KAAK,SAAS,kBAAkB;AAAA,MAC9B,GAAG,KAAK,aAAa;AAAA,MACrB,OAAA0C;AAAA,MACA,QAAQjD;AAAA,IAAA,CACT;AAAA,EACH;AAAA,EAEA,MAAa,WAAWuD,IAAS,MAAqB;AACpD,UAAM,KAAK,iBAAA,GACX,KAAKV,GAAcU,CAAM;AAAA,EAC3B;AAAA,EAEAV,GAAcU,IAAwB,MAAY;AAChD,SAAK,aAAa,OAAO,YAAY,IACrC,KAAK,aAAa,qBAAqB,GACvC,KAAK,SAAS,uBAAuBA,CAAM,GAC3ChD,EAAQ,gBAAgB,IAAI;AAAA,EAC9B;AAAA,EAEAiD,GAAoBxD,GAAkB;AACpC,SAAK,aAAa,OAAO,iBAAiBA,EAAM,OAAO,SAAS,eAAe;AAAA,EACjF;AAAA,EAEA,eAAeD,GAAW;AACxB,UAAM0D,IAA4B,KAAK,aAAa,OAAO;AAe3D,QAbI1D,EAAK,SAAS,gBAAiBA,EAAK,SAAS,WAAWA,EAAK,SAAS,iBACxE,KAAK,aAAa,OAAO,YAAY,KAC5BA,EAAK,SAAS,cACvB,KAAK,aAAa,OAAO,YAAY,KAGvCQ,EAAQ,gBAAgB,IAAI,GACxB,CAACkD,KAAoB,KAAK,aAAa,OAAO,cAChD,KAAK,SAAS,kBAAkB,GAChC,KAAKX,GAAkB,EAAK,IAI1B/C,EAAK,SAAS;AAChB,WAAK2D,GAAmB,IAAI,WAAW3D,EAAK,IAAI,CAAC;AAAA,aACxCA,EAAK,SAAS,SAAS;AAChC,YAAMU,IAAQ,IAAI,MAAM,gDAAgD;AACxE,WAAK,aAAaA,CAAK;AAAA,IACzB,MAAA,CAAWV,EAAK,SAAS,aACvB,KAAK,QAAQA,EAAK,KAAK,SAAS,IAAI,KAAK,cAAc,SAAS;AAGlE,SAAK,aAAa,OAAO,cAAc;AAAA,EACzC;AAAA,EAEA,MAAa,UAA4B;AACvC,WAAI,KAAK,cACA,MAGT,KAAK,aAAa,OAAO,iBAAiB,QAEnC,IAAI,QAAQ,CAACe,GAAmC6C,MAA2C;AAChG,MAAK,KAAK9B,OACR,KAAKA,KAAyB,KAAK2B,GAAoB,KAAK,IAAI,IAGlE,KAAK,GAAG,uBAAuB,KAAK3B,EAAsB;AAE1D,YAAM+B,IAA2C,YAAY,MAAY;AACvE,QAAI,KAAK,aAAa,OAAO,mBAAmB,cAC9C,cAAcA,CAAQ,GACtB,KAAK,aAAa,OAAO,iBAAiB,QAC7B,KAAK/B,OAAd,QACF,KAAK,IAAI,uBAAuB,KAAKA,EAAsB,GAGzD,KAAK,cACPf,EAAQ,EAAI,IAEZ6C,EAAO,GAAG,KAAK,UAAU,WAAW,KAAK,YAAY,gBAAgB,KAE9D,KAAK,aAAa,OAAO,mBAAmB,iBACrD,KAAK,aAAa,OAAO,iBAAiB,QAC1C,KAAK,SAAS,uBAAuB,EAAE,QAAQ,IAAM,GACrD,KAAK,SAAS,qBAAqB,EAAE,QAAQ,IAAM;AAAA,MAEvD,GAAG,GAAG;AAEN,WAAK,cAAA;AAAA,IACP,CAAC;AAAA,EACH;AAAA,EAEA,MAAa,mBAAkC;AAC7C,QAAI;AACF,UAAI,KAAK;AACP,QAAIjC,EAAO,iBACTA,EAAO,iBAAiB,KAAK,kBAAkB;AAAA,WAE5C;AACL,cAAMmC,IAAyD,KAAK,aAAa,OAAO,QAClFC,IAAmD,KAAK,aAAa,OAAO;AAClF,QAAID,MAEF,MADsCA,EAAO,OAAA,EACxB,MAAM,CAACE,MAAuB,KAAK,aAAaA,CAAG,CAAC,GACzE,MAAM,KAAK,aAAa,OAAO,aAG7BD,MACF,MAAMA,EAAc,UAAA,EAAY,MAAA,GAChC,MAAM,KAAK,aAAa,OAAO,cAG7B,KAAK,aAAa,OAAO,aAAa,KAAK,aAAa,UAAU,KAAK,aAAa,OAAO,QAC7F,MAAM,KAAK,aAAa,OAAO,KAAK,MAAA;AAAA,MAExC;AAAA,IACF,SAASC,GAAc;AACrB,WAAK,aAAaA,CAAG;AAAA,IACvB,UAAA;AACE,WAAK,aAAa,OAAO,SAAS,MAClC,KAAK,aAAa,OAAO,aAAa,MAEtC,KAAK,aAAa,OAAO,gBAAgB,MACzC,KAAK,aAAa,OAAO,cAAc,MAEvC,KAAK,aAAa,OAAO,YAAY,IACrC,KAAK,aAAa,OAAO,OAAO,MAChCxD,EAAQ,gBAAgB,IAAI;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,MAAMyD,GAAmBjE,GAA0E;AACjG,QAAI2B,EAAO;AACT,iBAAKmB,GAAc,EAAE,OAAO,0BAAA,CAA2B,GACjD,IAAI,MAAM,4BAA4B;AAG9C,QAAI,KAAK;AACP,iBAAKA,GAAc,EAAE,OAAO,4CAAA,CAA6C,GACnE,IAAI,MAAM,gDAAgD;AAGlE,UAAMI,IAAoB,KAAK,cAAclD,CAAI;AACjD,IAAA2B,EAAO,MAAM,EAAE,QAAQ,KAAK,oBAAoB,OAAO,MAAM,KAAKuB,CAAK,GAAG;AAAA,EAC5E;AAAA,EAEA,MAAMgB,GAAalE,GAA0E;AAC3F,QAAI,KAAK,WAAW;AAClB,YAAM,KAAKiE,GAAmBjE,CAAI;AAClC;AAAA,IACF;AACA,UAAMuD,IAA0B,KAAK,aAAa,OAAO;AACzD,QAAI,CAACA,KAASA,MAAS,CAACA,EAAK,YAAY,CAACA,EAAK;AAC7C,iBAAKT,GAAc,EAAE,OAAO,4CAAA,CAA6C,GACnE,IAAI,MAAM,gDAAgD;AAElE,UAAMI,IAAoB,KAAK,cAAclD,CAAI;AAMjD,QAJI,KAAK,aACP,MAAM,KAAKmE,GAAYZ,GAAM,GAAI,GAG/BA,EAAK,aAAa,KAAM;AAC5B,UAAMa,IAAkDb,EAAK,SAAS,UAAA;AACtE,UAAMa,EAAO,MAAMlB,CAAK,GACxBkB,EAAO,YAAA;AAAA,EACT;AAAA,EAEA,MAAMD,GAAYZ,GAAkBc,IAAoB,KAAqB;AAC3E,UAAMC,IAAQ,KAAK,IAAA;AACnB,eAAa;AACX,UAAI,KAAK,QAAQA,IAAQD;AACvB,cAAM,IAAI,MAAM,wCAAwC;AAG1D,YAAM,EAAE,aAAAE,EAAA,IAAgB,MAAMhB,EAAK,WAAA;AACnC,UAAIgB,EAAa;AACjB,YAAMzD,EAAK,GAAG;AAAA,IAChB;AAAA,EACF;AAAA,EAEA6C,GAAmBa,IAAmB,IAAI,WAAW,CAAA,CAAE,GAAGC,IAAmB,IAAO;AAClF,QAAID,KAAQA,EAAK,SAAS,GAAG;AAC3B,YAAMd,IAA4B,KAAK,aAAa,OAAO;AAkB3D,UAjBA,KAAK,aAAa,OAAO,YAAY,KAAKb,GAAmB,KAAK,aAAa,OAAO,IAAI,GAC1FrC,EAAQ,gBAAgB,IAAI,GACxB,CAACkD,KAAoB,KAAK,aAAa,OAAO,cAChD,KAAK,SAAS,kBAAkB,GAChC,KAAKX,GAAkB,EAAK,IAG1B,KAAK,aAAa,SAAS,iBAC7B,cAAc,KAAK,aAAa,SAAS,YAAY,GACrD,KAAK,aAAa,SAAS,eAAe,IAGxC,KAAK,aAAa,QAAQ,mBAC5B,aAAa,KAAK,aAAa,QAAQ,cAAc,GACrD,KAAK,aAAa,QAAQ,iBAAiB,IAGzC,KAAK,aAAa,OAAO,SAAS,OAAO;AAC3C,QAAI0B,IACF,KAAK,qBAAqB,KAAK,gBAAgBD,CAAI,CAAC,IAEpD,KAAK,cAAc,KAAK,gBAAgBA,CAAI,CAAC;AAAA,eAEtC,KAAK,aAAa,OAAO,SAAS,OAAO;AAClD,QAAIC,IACF,KAAK,qBAAqBD,CAAI,IAE9B,KAAK,cAAcA,CAAI;AAAA,eAEhB,KAAK,aAAa,OAAO,SAAS,OAAO,UAAU;AAC5D,cAAME,IAAM,KAAK,wBAAwBF,CAAI;AAC7C,YAAI,KAAK,aAAa,OAAO,SAAS,YAAY,MAAM;AACtD,gBAAMG,IAAUD,EAAI,MAAM,KAAK,aAAa,OAAO,SAAS,OAAO;AACnE,qBAAWE,KAAKD;AACd,YAAKA,EAAQC,CAAC,MACVH,IACF,KAAK,qBAAqBE,EAAQC,CAAC,CAAC,IAEpC,KAAK,cAAcD,EAAQC,CAAC,CAAC;AAAA,QAGnC;AACE,UAAIH,IACF,KAAK,qBAAqBC,CAAG,IAE7B,KAAK,cAAcA,CAAG;AAAA,MAG5B,OAAO;AACL,cAAMG,IAA6C,KAAK,oBAAoB,KAAK,wBAAwBL,CAAI,CAAC;AAC9G,QAAIC,IACF,KAAK,qBAAqBI,CAA0B,IAEpD,KAAK,cAAcA,CAA0B;AAAA,MAEjD;AAAA,IACF;AAEA,QAAI,KAAK,aAAa,OAAO,MAAM,WAAW,GAAG;AAC/C,WAAK,aAAa,OAAO,gBAAgB;AACzC;AAAA,IACF;AACA,SAAK,SAAS,kBAAkB,EAAE;AAAA,EACpC;AAAA,EAEO,2BAAiC;AACtC,SAAK,aAAa,OAAO,SAAS,KAAK;AAAA,EACzC;AAAA,EAEO,wBAA8B;AACnC,SAAK,aAAa,OAAO,SAAS,KAAK;AAAA,EACzC;AAAA,EAEO,0BAAgC;AACrC,SAAK,aAAa,OAAO,SAAS,KAAK;AAAA,EACzC;AAAA,EAEO,sBAA4B;AACjC,SAAK,aAAa,OAAO,SAAS,KAAK;AAAA,EACzC;AAAA,EAEA,MAAMC,KAA8C;AAClD,UAAM/C,IAA8B,KAAK,eAEnCgD,IAAsB,MAAM,UAAU,OAAO,SAAS,EAAE,SAAAhD,GAAS;AACvE,WAAIA,EAAQ,WAAW,IAAUgD,IAEGA,EAAM,OAAO,CAACxB,MAA8B;AAC9E,YAAMyB,IAAuBzB,EAAK,QAAA;AAClC,aAAOxB,EAAQ,KAAK,CAACkD,MACZD,EAAK,iBAAiBC,EAAO,gBAAgBD,EAAK,gBAAgBC,EAAO,WACjF;AAAA,IACH,CAAC,EAGoB,OAAO,CAAC1B,MAA8B,CAAC,KAAKV,GAAmBU,CAAI,CAAC;AAAA,EAC3F;AAAA,EAEA,MAAa,iBAAiBwB,GAAoC;AAChE,UAAMhD,IAA8B,KAAK;AACzC,QAAI,KAAK,aAAa,qBAAqBgD,EAAM,QAAQ;AACvD,YAAMG,IAAM,KAAK,aAAa;AAC9B,WAAK,aAAa,OAAO,OAAOH,EAAMG,CAAG;AAAA,IAC3C;AACE,WAAK,aAAa,qBAAqB,GACvC,KAAK,aAAa,OAAO,OAAO,MAAM,UAAU,OAAO,YAAY;AAAA,QACjE,SAAAnD;AAAA,MAAA,CACD;AAEH,QAAI,CAAC,KAAK,aAAa,OAAO;AAC5B,YAAM,IAAI,MAAM,4BAA4B;AAAA,EAEhD;AAAA,EAEO,aAAarB,GAAkB;AACpC,UAAMsD,IAAMtD,EAAM,SAAA,EAAW,YAAA;AAC7B,YAAQ,IAAA;AAAA,MACN,KAAKsD,EAAI,SAAS,8DAA8D;AAAA,MAChF,KAAKA,EAAI,SAAS,qBAAqB;AAAA,MACvC,KAAKA,EAAI,SAAS,uCAAuC;AAAA,MACzD,KAAKA,EAAI,SAAS,uCAAuC;AAAA,MACzD,KAAKA,EAAI,SAAS,gDAAgD;AAAA,MAClE,KAAKA,EAAI,SAAS,4BAA4B;AAAA,MAC9C,KAAKA,EAAI,SAAS,8BAA8B;AAAA,MAChD,KAAKA,EAAI;AAAA,QACP;AAAA,MAAA;AAEA,aAAK,SAAS,0BAA0B,EAAE,GAC1CxD,EAAQ,gBAAgB,IAAI;AAC5B;AAAA,MACF,KAAKwD,EAAI,SAAS,2BAA2B;AAAA,MAC7C,KAAKA,EAAI,SAAS,4BAA4B;AAC5C,aAAK,mBAAmB,KAAK,YAAY;AACvC,eAAK,aAAa,sBAAsB,GACxC,MAAM,KAAK,cAAA;AAAA,QACb,CAAC;AACD;AAAA,MACF,KAAKA,EAAI,SAAS,0DAA0D;AAAA,MAC5E,KAAKA,EAAI,SAAS,qDAAqD;AAAA,MACvE,KAAKA,EAAI,SAAS,yCAAyC;AAAA,MAC3D,KAAKA,EAAI,SAAS,8CAA8C;AAC9D,aAAK,mBAAmB,KAAK,YAAY;AACvC,gBAAM,KAAK,cAAA;AAAA,QACb,CAAC;AACD;AAAA,MACF,KAAKA,EAAI,SAAS,oEAAoE;AAEpF;AAAA,MACF,KAAKA,EAAI,SAAS,oFAAoF;AAEpG;AAAA,MACF,KAAKA,EAAI,SAAS,6BAA6B;AAE7C;AAAA,MACF,KAAKA,EAAI,SAAS,0BAA0B;AAC1C,aAAK,SAAS,eAAe,EAAE,GAC/BxD,EAAQ,gBAAgB,IAAI;AAE5B;AAAA,MACF,KAAKwD,EAAI,SAAS,+BAA+B;AAC/C,aAAK,SAAS,sBAAsB,EAAE;AAEtC;AAAA,MACF;AAEE,gBAAQ,MAAMtD,CAAK;AACnB;AAAA,IAAA;AAGJ,SAAK,SAAS,gBAAgBA,CAAK;AAAA,EACrC;AAAA,EAEAyE,GAAcN,GAAoD;AAChE,QAAIA,GAAa;AACf,YAAMO,IAAuB,KAAK,aAAa,OAAO,SAAS,QACzDC,IAAkB,IAAI,WAAWD,EAAS,SAASP,EAAY,UAAU;AAC/E,MAAAQ,EAAI,IAAID,GAAU,CAAC,GACnBC,EAAI,IAAI,IAAI,WAAWR,CAAW,GAAGO,EAAS,MAAM,GACpD,KAAK,aAAa,OAAO,SAAS,SAASC;AAAA,IAC7C;AAAA,EACF;AAAA,EAEA,MAAMC,KAAsC;AAC1C,IAAI,KAAK,aAAa,OAAO,0BAC3B,aAAa,KAAK,aAAa,OAAO,qBAAqB,GAC3D,KAAK,aAAa,OAAO,wBAAwB,IAG/C,KAAK,aAAa,OAAO,SAAS,UACpC,KAAK3B,GAAmB,KAAK,aAAa,OAAO,SAAS,MAAM,GAElE,KAAK,aAAa,OAAO,SAAS,SAAS,IAAI,WAAW,CAAC;AAAA,EAC7D;AAAA,EAEA,MAAM4B,KAAiC;AACrC,IAAI,KAAK,aAAa,OAAO,0BAC3B,aAAa,KAAK,aAAa,OAAO,qBAAqB,GAC3D,KAAK,aAAa,OAAO,wBAAwB,IAGnD,KAAK,aAAa,OAAO,wBAAwB,WAAW,MAAY;AACtE,MAAI,KAAK,aAAa,OAAO,SAAS,UACpC,KAAK5B,GAAmB,KAAK,aAAa,OAAO,SAAS,MAAM,GAGlE,KAAK,aAAa,OAAO,SAAS,SAAS,IAAI,WAAW,CAAC;AAAA,IAC7D,GAAG,KAAK,aAAa,OAAO,mBAAmB,EAAE;AAAA,EACnD;AAAA,EAEA,MAAM6B,KAAmC;AACvC,UAAMC,IAAiB,KAAK,aAAa,OAAO,SAAS;AACzD,QAAIC,IAAS,KAAK,aAAa,OAAO,SAAS;AAO/C,QALI,KAAK,aAAa,OAAO,0BAC3B,aAAa,KAAK,aAAa,OAAO,qBAAqB,GAC3D,KAAK,aAAa,OAAO,wBAAwB,IAG/C,EAAAD,MAAmB,QAAQ,CAACC,KAAUA,EAAO,WAAW,IAE5D;AAAA,aAAOA,EAAO,UAAUD,KAAgB;AACtC,cAAME,IAAUD,EAAO,MAAM,GAAGD,CAAc;AAC9C,aAAK9B,GAAmBgC,CAAO,GAE/BD,IAASA,EAAO,MAAMD,CAAc;AAAA,MACtC;AACA,WAAK,aAAa,OAAO,SAAS,SAASC,GAEvCA,EAAO,SAAS,MAClB,KAAK,aAAa,OAAO,wBAAwB,WAAW,MAAY;AACtE,aAAK/B,GAAmB,KAAK,aAAa,OAAO,SAAS,QAAQ,EAAI;AAAA,MACxE,GAAG,KAAK,aAAa,OAAO,mBAAmB,EAAE;AAAA;AAAA,EAErD;AAAA,EAEA,MAAMiC,KAAsC;AAC1C,UAAM;AAAA,MACJ,SAAA5C;AAAA,MACA,eAAA6C,IAAgB;AAAA,MAChB,cAAAC,IAAe;AAAA,IAAA,IAKb,KAAK,aAAa,OAAO;AAE7B,QAAI,CAAC9C;AACH,YAAM,IAAI,MAAM,kDAAkD;AAGpE,UAAM0C,IAAS,KAAK,aAAa,OAAO,SAAS;AAEjD,QAAI,CAAC1C,KAAW,CAAC0C,KAAUA,EAAO,WAAW,EAAG;AAEhD,IAAI,KAAK,aAAa,OAAO,0BAC3B,aAAa,KAAK,aAAa,OAAO,qBAAqB,GAC3D,KAAK,aAAa,OAAO,wBAAwB;AAInD,QAAIK,IADY,IAAI,YAAA,EACE,OAAOL,CAAM;AACnC,UAAMM,IAAyB,CAAA;AAE/B,QAAI,OAAOhD,KAAY,UAAU;AAC/B,UAAIiD;AACJ,UAAIJ,KAAiBC;AACnB,QAAAG,IAAU,IAAI,OAAO,GAAGjD,CAAO,MAAMA,CAAO,MAAMA,CAAO,IAAI,GAAG;AAAA,eACvD6C;AACT,QAAAI,IAAU,IAAI,OAAO,GAAGjD,CAAO,MAAMA,CAAO,OAAO,GAAG;AAAA,eAC7C8C;AACT,QAAAG,IAAU,IAAI,OAAO,MAAMjD,CAAO,MAAMA,CAAO,IAAI,GAAG;AAAA;AAEtD;AAGF,UAAIkD,GACAC,IAAY;AAChB,cAAQD,IAAQD,EAAQ,KAAKF,CAAO,OAAO;AACzC,QAAAC,EAAS,KAAK,IAAI,YAAA,EAAc,OAAOE,EAAM,CAAC,CAAC,CAAC,GAChDC,IAAYF,EAAQ;AAGtB,MAAAF,IAAUA,EAAQ,MAAMI,CAAS;AAAA,IACnC,WAAWnD,aAAmB,QAAQ;AACpC,UAAIkD,GACAC,IAAY;AAChB,UAAIN,KAAiBC,GAAc;AACjC,cAAMG,IAAU,IAAI,OAAO,GAAGjD,EAAQ,MAAM,QAAQA,EAAQ,MAAM,IAAI,GAAG;AACzE,gBAAQkD,IAAQD,EAAQ,KAAKF,CAAO,OAAO;AACzC,UAAAC,EAAS,KAAK,IAAI,YAAA,EAAc,OAAOE,EAAM,CAAC,CAAC,CAAC,GAChDC,IAAYF,EAAQ;AAAA,MAExB,WAAWH;AACT,gBAAQI,IAAQlD,EAAQ,KAAK+C,CAAO,OAAO,QAAM;AAC/C,gBAAMK,IAAMF,EAAM,OACZG,IAAQN,EAAQ,MAAMI,GAAWC,CAAG;AAC1C,UAAAJ,EAAS,KAAK,IAAI,YAAA,EAAc,OAAOK,CAAK,CAAC,GAC7CF,IAAYnD,EAAQ;AAAA,QACtB;AAAA,eACS6C,GAAe;AACxB,cAAMS,IAAQP,EAAQ,MAAM/C,CAAO;AACnC,QAAAsD,EAAM,MAAA;AACN,mBAAWC,KAAQD;AACjB,UAAAN,EAAS,KAAK,IAAI,YAAA,EAAc,OAAOO,CAAI,CAAC;AAE9C,QAAAR,IAAU;AAAA,MACZ;AAEA,MAAAA,IAAUA,EAAQ,MAAMI,CAAS;AAAA,IACnC;AAEA,eAAWK,KAAOR;AAChB,WAAKrC,GAAmB6C,CAAG;AAG7B,UAAMC,IAAgB,IAAI,cAAc,OAAOV,CAAO;AACtD,SAAK,aAAa,OAAO,SAAS,SAASU,GAEvCA,EAAc,SAAS,MACzB,KAAK,aAAa,OAAO,wBAAwB,WAAW,MAAY;AACtE,WAAK9C,GAAmB,KAAK,aAAa,OAAO,SAAS,QAAQ,EAAI,GACtE,KAAK,aAAa,OAAO,SAAS,SAAS,IAAI,WAAW,CAAC;AAAA,IAC7D,GAAG,KAAK,aAAa,OAAO,mBAAmB,EAAE;AAAA,EAErD;AAAA,EAEA,MAAM+C,KAAiC;AACrC,UAAMnD,IAA0B,KAAK,aAAa,OAAO;AACzD,QAAI,CAACA,KAAQ,CAACA,EAAK,SAAU,OAAM,IAAI,MAAM,sBAAsB;AAEnE,UAAMoD,IAAS,KAAK,aAAa,OAAO,kBAAkB,KAAK,aAAa,OAAO,kBAAkB,MAC/F7C,IAAkD6C,IACpDpD,EAAK,SAAS,YAAYoD,CAAM,EAAE,UAAA,IAClCpD,EAAK,SAAS,UAAA;AAGlB,SAAK,aAAa,OAAO,SAASO;AAElC,QAAI;AACF,aAAO,KAAK,aAAa,OAAO,gBAAc;AAC5C,cAAM,EAAE,OAAApB,GAAO,MAAAkE,EAAA,IAAS,MAAM9C,EAAO,KAAA;AACrC,YAAI8C,EAAM;AAEV,aAAKzB,GAAczC,CAAK,GAEpB,KAAK,aAAa,OAAO,kBAC3B,MAAM,KAAK4C,GAAA,IACF,KAAK,aAAa,OAAO,SAAS,YAC3C,MAAM,KAAKM,GAAA,IACF,KAAK,aAAa,OAAO,SAAS,WAAW,OACtD,MAAM,KAAKL,GAAA,IAEX,MAAM,KAAKC,GAAA;AAAA,MAEf;AAAA,IACF,SAASxB,GAAc;AACrB,WAAK,aAAaA,CAAG;AAAA,IACvB,UAAA;AACE,MAAAF,EAAO,YAAA,GACP,KAAK,aAAa,OAAO,eAAe,IAEpC,KAAK,aAAa,OAAO,QAC3B,MAAM,KAAK,aAAa,OAAO,KAAK,MAAA;AAAA,IAExC;AAAA,EACF;AAAA,EAEAf,GAAkBL,GAAsB;AACtC,IAAIA,MAAU,KAAK,aAAa,OAAO,eAEvC,KAAK,aAAa,OAAO,aAAaA,GACtC,KAAK,SAAS,qBAAqB,EAAE,QAAQA,GAAO,GACpD,KAAK,SAAS,uBAAuB,EAAE,QAAQA,GAAO;AAAA,EACxD;AAAA,EAEA,MAAa,gBAA+B;AAC1C,QAAI;AAGF,UAFA,KAAKK,GAAkB,EAAI,GAEvB,KAAK,WAAW;AAMlB,YALApB,EAAO,QAAA,GACP,KAAK,aAAa,OAAO,cAAc,WACvC,KAAK,aAAa,QAAQ,iBAAiB,WAAW,YAA2B;AAC/E,gBAAM,KAAK,QAAQ,KAAK,aAAa,OAAO,oBAAoB,CAAA,GAAI,kBAAkB;AAAA,QACxF,GAAG,KAAK,aAAa,KAAK,mBAAmB,GACzCA,EAAO;AACT;AAEF,QAAAA,EAAO,cAAc,KAAK,kBAAkB,GAC5C,KAAK,SAAS,eAAe;AAAA,UAC3B,QAAQ;AAAA,UACR,OAAO,KAAK,aAAa,OAAO;AAAA,QAAA,CACjC;AAAA,MACH,OAAO;AACL,cAAMoD,IAAsB,MAAM,KAAKD,GAAA;AACvC,YAAIC,EAAM,SAAS;AACjB,gBAAM,KAAK,iBAAiBA,CAAK;AAAA,aAC5B;AACL,gBAAMhD,IAA8B,KAAK;AACzC,eAAK,aAAa,OAAO,OAAO,MAAM,UAAU,OAAO,YAAY;AAAA,YACjE,SAAAA;AAAA,UAAA,CACD;AAAA,QACH;AAEA,cAAMwB,IAA0B,KAAK,aAAa,OAAO;AACzD,YAAI,CAACA;AACH,gBAAM,IAAI,MAAM,8BAA8B;AAEhD,cAAMA,EAAK,KAAK,KAAK,gBAAgB;AAErC,cAAMpD,IAAc;AACpB,QAAAoD,EAAK,YAAY,CAACtD,MAAuB;AAEvC,UAAAE,EAAM,SAAS,oBAAoBF,CAAK,GACxCE,EAAM4C,GAAkB,EAAK,GAC7BvC,EAAQ,gBAAgB,IAAI,GACxBL,EAAM,aAAa,OAAO,MAAM,SAAS,IAC3CA,EAAM,SAAS,kBAAkB,EAAE,IAEnCA,EAAM,aAAa,OAAO,gBAAgB;AAAA,QAE9C,GACAoD,EAAK,eAAe,YAA2B;AAC7C,gBAAMpD,EAAM,WAAA;AAAA,QACd,GAEA,MAAMW,EAAK,KAAK,aAAa,OAAO,sBAAsB,GAE1D,KAAK,aAAa,QAAQ,iBAAiB,WAAW,YAA2B;AAC/E,gBAAMX,EAAM,QAAQA,EAAM,aAAa,OAAO,oBAAoB,CAAA,GAAI,kBAAkB;AAAA,QAC1F,GAAG,KAAK,aAAa,KAAK,mBAAmB,GAE7C,KAAK,aAAa,OAAO,cAAc,WACvC,MAAM,KAAK+D,GAAa,KAAK,aAAa,OAAO,oBAAoB,EAAE,GAEvE,KAAK,SAAS,eAAe;AAAA,UAC3B,QAAQ;AAAA,UACR,OAAO,KAAK,aAAa,OAAO;AAAA,QAAA,CACjC,GAEG,KAAK,aAAa,iBACpB,KAAKP,GAAmB,KAAK,aAAa,OAAO,aAAa,GAEhE,MAAM,KAAK+C,GAAA;AAAA,MACb;AAAA,IACF,SAAS,GAAY;AACnB,WAAK3D,GAAkB,EAAK,GAC5B,KAAK,aAAa,CAAC;AAAA,IACrB;AAAA,EACF;AAAA,EAEA,MAAM8D,KAA4B;AAChC,WAAI,OAAO,SAAW,MAAoB,KAEtC,YAAY,aAAa,YAAY,WAAW,aAAa,KAAK,aAAa,OAAO,QACxF,MAAM,KAAK,aAAa,OAAO,KAAK,OAAA,GAC7B,MAEF;AAAA,EACT;AAAA,EAEA,MAAa,eAAiC;AAC5C,WAAO,MAAM,KAAKA,GAAA;AAAA,EACpB;AAAA,EAEO,SAASC,GAA8B;AAC5C,WAAI,OAAOA,KAAQ,aACjBA,IAAM,SAASA,GAAK,EAAE,IAEjBA,EAAI,SAAS,EAAE;AAAA,EACxB;AAAA,EAEO,SAASC,GAAqB;AACnC,WAAO,SAASA,GAAK,EAAE;AAAA,EACzB;AAAA,EAEO,SAASC,IAAM,MAAMC,IAAM,GAAW;AAC3C,WAAOD,EAAI,WAAW,SAASC,GAAK,GAAG,EAAE,YAAA;AAAA,EAC3C;AAAA,EAEO,MAAM/D,GAA2B;AACtC,UAAMgE,IAAsB,CAAA;AAC5B,WAAAhE,EAAM,QAAQ,CAACR,GAAeyE,MAAwB;AACpD,MAAAD,EAAUC,CAAK,IAAI,OAAOzE;AAAA,IAC5B,CAAC,GACMwE;AAAA,EACT;AAAA,EAEO,WAAWhE,GAA2B;AAC3C,WAAO,KAAK,MAAM,MAAM,KAAKA,GAAO,CAACkE,MAAyB,KAAK,SAASA,CAAI,CAAC,CAAC;AAAA,EACpF;AAAA,EAEA7E,KAAkC;AAmBhC,IAlBqC;AAAA,MACnC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IAAA,EAGiB,QAAQ,CAACtC,MAAwB;AAClD,WAAK,gCAAgCA,CAAK;AAAA,IAC5C,CAAC;AAAA,EACH;AAAA,EAEAuC,KAAwB;AAEtB,UAAMrC,IAAc;AACpB,SAAK,GAAG,kBAAkB,YAA2B;AACnD,YAAMA,EAAMkH,GAAA;AAAA,IACd,CAAC;AAED,UAAMC,IAA2B,MAAY;AAC3C,MAAInH,EAAM,eACRA,EAAM2C,GAAc,EAAE,OAAO,uBAAA,CAAwB;AAAA,IAEzD,GACMyE,IAAwB,MAAY;AACxC,MAAIpH,EAAM,kBAAkB,CAACA,EAAM,gBACjCA,EAAM,gBAAgB,MAAM,MAAY;AAAA,MAAC,CAAC;AAAA,IAE9C;AACA,IAAI,KAAK,cACP,OAAO,iBAAiB,8BAA8BmH,CAAwB,GAC9E,OAAO,iBAAiB,2BAA2BC,CAAqB,IAG1E,KAAKC,GAAA;AAAA,EACP;AAAA,EAEAA,KAAuB;AAErB,UAAMrH,IAAc;AACpB,cAAU,OAAO,iBAAiB,WAAW,YAA2B;AACtE,MAAKA,EAAM,kBACX,MAAMA,EAAM,gBAAgB,MAAM,MAAY;AAAA,MAAC,CAAC;AAAA,IAClD,CAAC;AAAA,EACH;AAAA,EAEA,MAAMkH,KAA2B;AAC/B,QAAI,KAAK,aAAa1F,EAAO,eAAA;AAM3B;AAEF,QAAI,CAAC,KAAKkB,GAAmB,KAAK,aAAa,OAAO,IAAI,GAAG;AAC3D,WAAKC,GAAc,EAAE,OAAO,4CAAA,CAA6C,GACzE,MAAM,KAAK,cAAA;AACX;AAAA,IACF;AAGA,QAAI,KAAK,aAAa,QAAQ,eAAgB;AAE9C,QAAI,KAAK,aAAa,OAAO,MAAM,WAAW,GAAG;AAC/C,WAAK,aAAa,OAAO,gBAAgB;AACzC;AAAA,IACF;AACA,SAAK,aAAa,OAAO,gBAAgB;AAGzC,UAAM2E,IAAmB,KAAK,aAAa,OAAO,MAAM,CAAC;AACzD,QAAIC,IAAyB,KAAK,aAAa,KAAK;AAiBpD,QAhBID,EAAM,WAAW,cACnBC,IAAiB,KAAK,aAAa,KAAK,sBAG1C,KAAK,aAAa,QAAQ,iBAAiB,WAAW,YAA2B;AAC/E,YAAM,KAAK,QAAQD,EAAM,OAAOA,EAAM,MAAM;AAAA,IAC9C,GAAGC,CAAc,GAEjB,KAAK,aAAa,OAAO,cAAcD,EAAM,UAAU,WACvD,MAAM,KAAKvD,GAAauD,EAAM,KAAK,GAEnC,KAAK,SAAS,eAAe;AAAA,MAC3B,QAAQA,EAAM;AAAA,MACd,OAAOA,EAAM;AAAA,IAAA,CACd,GAEG,KAAK,aAAa,eAAe;AACnC,UAAIvE,IAAoB,IAAI,WAAW,CAAC;AACxC,UAAI;AACF,QAAAA,IAAQ,KAAK,cAAc,KAAK,aAAa,OAAO,aAAa;AAAA,MACnE,SAASyE,GAAY;AACnB,aAAK,aAAaA,CAAC;AAAA,MACrB;AAEA,WAAKhE,GAAmBT,CAAK;AAAA,IAC/B;AACA,UAAM0E,IAA0B,CAAC,GAAG,KAAK,aAAa,OAAO,KAAK;AAClE,SAAK,aAAa,OAAO,QAAQA,EAAW,OAAO,CAAC,GAEhD,KAAK,aAAa,OAAO,MAAM,SAAS,MAC1C,KAAK,aAAa,OAAO,gBAAgB;AAAA,EAG7C;AAAA,EAEO,cAAc5H,GAAuE;AAC1F,QAAIkD,IAAoB,IAAI,WAAW,CAAC;AACxC,QAAIlD,aAAgB;AAClB,MAAAkD,IAAQlD;AAAA,aACC,OAAOA,KAAS;AACzB,MAAAkD,IAAQ,KAAK,yBAAyBlD,CAAI;AAAA,aACjC,MAAM,QAAQA,CAAI,KAAK,OAAOA,EAAK,CAAC,KAAM;AACnD,MAAAkD,IAAQ,KAAK,wBAAwBlD,CAAgB;AAAA,aAC5C,MAAM,QAAQA,CAAI,KAAK,OAAOA,EAAK,CAAC,KAAM;AACnD,MAAAkD,IAAQ,IAAI,WAAWlD,CAA2B;AAAA;AAElD,YAAM,IAAI,MAAM,mBAAmB;AAErC,WAAOkD;AAAA,EACT;AAAA,EAEA,MAAa,cAAc2E,GAAgDC,GAA+B;AACxG,UAAM5E,IAAoB,KAAK,cAAc2E,CAAG;AAEhD,QAAI,CAAC,WAAW,kBAAkB,EAAE,SAASC,CAAM,GAAG;AACpD,UAAI,KAAK,aAAa,OAAO,UAAW;AAKxC,YAAM,KAAK,cAAA;AACX;AAAA,IACF;AAEA,SAAK,aAAa,OAAO,MAAM,KAAK,EAAE,OAAA5E,GAAO,QAAA4E,GAAQ,GACrD,KAAK,SAAS,kBAAkB,EAAE;AAAA,EACpC;AAAA,EAEAxF,GAA0BL,IAAY,GAAS;AAE7C,IADA,KAAK,aAAa,gBAAgBA,GAC9B,MAAK,aAAa,gCACtB,KAAK,aAAa,OAAO,mBAAmB,KAAK,4BAA4BA,CAAS;AAAA,EACxF;AAAA,EAEO,4BAA4B8F,IAAiB,GAAqD;AACvG,QAAI,KAAK,aAAa,4BAA6B,QAAO,KAAK,aAAa,OAAO;AAInF,UAAM,IAAI,MAAM,6EAA6EA,CAAc,EAAE;AAAA,EAG/G;AAAA,EAEO,cAAcvD,GAA2E;AAG9F,kBAAQ,IAAIA,CAAI,GAChB,KAAK,SAAS,kBAAkB,EAAE,MAAAA,EAAA,CAAY,GACxC,IAAI,MAAM,wCAAwC;AAAA,EAC1D;AAAA,EAEO,qBAAqBA,GAAoF;AAE9G,kBAAQ,IAAIA,CAAI,GAChB,KAAK,SAAS,0BAA0B,EAAE,MAAAA,EAAA,CAAM,GAC1C,IAAI,MAAM,+CAA+C;AAAA,EACjE;AAAA,EAEAwD,KAAwB;AACtB,SAAK,aAAa,aAAa;AAAA,MAC7B,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,MAAM;AAAA,MACN,SAAS;AAAA,IAAA;AAAA,EAEb;AAAA,EAEO,mBAAyB;AAC9B,SAAK,aAAa,OAAO,QAAQ,CAAA;AAAA,EACnC;AAAA,EAEO,OAAOH,GAAuB;AACnC,QAAII,IAAc;AAClB,WAAAJ,EAAI,QAAQ,CAACnF,MAAwB;AACnC,MAAAuF,KAAO,SAASvF,GAAO,EAAE;AAAA,IAC3B,CAAC,GACMuF,EAAI,SAAS,EAAE;AAAA,EACxB;AAAA,EAEO,WAAmB;AACxB,WAAO,KAAK,UAAU;AAAA,MACpB,SAAS,KAAK;AAAA,MACd,eAAe,KAAK;AAAA,MACpB,MAAM,KAAK;AAAA,MACX,WAAW,KAAK;AAAA,MAChB,YAAY,KAAK,aAAa,OAAO;AAAA,IAAA,CACtC;AAAA,EACH;AAAA,EAEO,aAAmB;AACxB,SAAKD,GAAA,GACL,KAAK,SAAS,sBAAsB,EAAE;AAAA,EACxC;AAAA,EAEA,MAAa,cAA6B;AACxC,QAAI,CAAC,KAAK,aAAa,OAAO;AAC5B,YAAM,IAAI,MAAM,6BAA6B;AAE/C,UAAM,KAAK,cAAc,KAAK,aAAa,OAAO,kBAAkB,SAAS;AAAA,EAC/E;AAAA,EAEA,MAAa,eAAe,EAAE,MAAAxD,IAAO,CAAA,EAAC,IAAkB,EAAE,MAAM,CAAA,KAAqB;AACnF,QAAI,CAACA;AACH,YAAM,IAAI,MAAM,iBAAiB;AAGnC,IAAI,KAAK,aAAa,gCACpB,KAAK,aAAa,OAAO,mBAAmB,KAAK,cAAcA,CAAI,IAGrE,MAAM,KAAK,cAAcA,GAAM,QAAQ;AAAA,EACzC;AAAA,EAEO,iBAAiBlB,GAA0B;AAChD,WAAO,MAAM,KAAKA,CAAM,EAAE,IAAI,CAAC4E,MAAyBA,EAAK,WAAW,CAAC,EAAE,SAAS,EAAE,CAAC;AAAA,EACzF;AAAA,EAEO,oBAAoB5E,GAAgB8C,IAAc;AAAA,GAAuB;AAC9E,WAAO,KAAK,yBAAyB9C,GAAQ8C,CAAG,EAAE;AAAA,EACpD;AAAA,EAEO,yBAAyB9C,IAAiB,IAAI8C,IAAc;AAAA,GAAkB;AACnF,UAAM+B,IAAU,IAAI,YAAA;AACpB,WAAA7E,KAAU8C,GACH+B,EAAQ,OAAO7E,CAAM;AAAA,EAC9B;AAAA,EAEO,mBAAmBA,IAAiB,IAAI8C,IAAc;AAAA,GAAgB;AAC3E,UAAMgC,IAAsB,KAAK,yBAAyB9E,GAAQ8C,CAAG;AACrE,WAAO,MAAM,KAAKgC,CAAO,EAAE,IAAI,CAAChB,MAAyBA,EAAK,SAAS,EAAE,CAAC;AAAA,EAC5E;AAAA,EAEO,gBAAgBiB,GAA6B;AAClD,WAAO,MAAM,KAAKA,CAAK,EAAE,IAAI,CAACjB,MAAyBA,EAAK,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,EAAE,aAAa;AAAA,EACzG;AAAA,EAEO,gBAAgBiB,GAA6B;AAClD,WAAO,IAAI,WAAWA,EAAM,IAAI,CAACC,MAA8B,SAASA,GAAW,EAAE,CAAC,CAAC;AAAA,EACzF;AAAA,EAEO,wBAAwBC,GAA+B;AAC5D,UAAMrF,IAAkB,CAAA;AACxB,WAAI,OAAOqF,KAAY,WACd,KAAK,yBAAyBA,CAAO,EAAE,UAEhDA,EAAQ,QAAQ,CAAC7D,MAAsB;AACrC,YAAMqC,IAAMrC,EAAI,QAAQ,MAAM,EAAE;AAChC,MAAAxB,EAAM,KAAK,SAAS6D,GAAK,EAAE,CAAC;AAAA,IAC9B,CAAC,GAEM,IAAI,WAAW7D,CAAK;AAAA,EAC7B;AAAA,EAEO,wBAAwBmF,GAAsC;AACnE,QAAIG,IAAyB,IAAI,WAAW,CAAC;AAC7C,IAAIH,aAAiB,aACnBG,IAAaH,IAEbG,IAAa,KAAK,wBAAwBH,CAAiB,GAG7DA,IAAQ,KAAK,gBAAgBG,CAAU;AACvC,UAAMC,IAAsBJ,EAAM,IAAI,CAACC,MAA8B,SAASA,GAAW,EAAE,CAAC;AAC5F,WAAI,KAAK,aAAa,OAAO,SAAS,WAC7B,OAAO,aAAa,GAAGG,CAAS,EAAE,QAAQ,KAAK,aAAa,OAAO,SAAS,UAAU,EAAE,IAE1F,OAAO,aAAa,GAAGA,CAAS;AAAA,EACzC;AAAA,EAEO,WAAW1B,GAA8B;AAC9C,UAAMuB,IAAoBvB,EAAI,SAAA;AAC9B,QAAI2B,IAAsB;AAC1B,aAAS,IAAY,GAAG,IAAIJ,EAAU,QAAQ,KAAK;AACjD,MAAAI,KAAe,OAAO,aAAa,SAASJ,EAAU,UAAU,GAAG,CAAC,GAAG,EAAE,CAAC;AAE5E,WAAOI;AAAA,EACT;AAAA,EAEO,WAAWA,GAA6B;AAC7C,UAAMC,IAAqB,CAAA;AAC3B,aAASC,IAAY,GAAG3F,IAAiByF,EAAY,QAAQE,IAAI3F,GAAQ2F,KAAK;AAC5E,YAAM7B,IAAc,OAAO2B,EAAY,WAAWE,CAAC,CAAC,EAAE,SAAS,EAAE;AACjE,MAAAD,EAAS,KAAK5B,CAAG;AAAA,IACnB;AACA,WAAO4B,EAAS,KAAK,EAAE;AAAA,EACzB;AAAA,EAEO,8BAAuC;AAC5C,WAAO,KAAK;AAAA,EACd;AACF;AChrDO,IAAKE,sBAAAA,OACVA,EAAA,oBAAoB,qBACpBA,EAAA,uBAAuB,wBACvBA,EAAA,eAAe,gBACfA,EAAA,cAAc,eACdA,EAAA,UAAU,WACVA,EAAA,iBAAiB,kBACjBA,EAAA,oBAAoB,qBACpBA,EAAA,uBAAuB,wBACvBA,EAAA,wBAAwB,yBACxBA,EAAA,eAAe,gBACfA,EAAA,gBAAgB,iBAXNA,IAAAA,KAAA,CAAA,CAAA;AAmBL,MAAMC,UAAoB,MAAM;AAAA;AAAA;AAAA;AAAA,EAIrB;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBhB,YACEnD,GACAnB,IAAwB,iBACxBuE,GACA;AACA,UAAMpD,CAAO,GACb,KAAK,OAAO,eACZ,KAAK,OAAOnB,GACZ,KAAK,UAAUuE,GACf,KAAK,gCAAgB,KAAA,GAGjB,MAAM,qBACR,MAAM,kBAAkB,MAAMD,CAAW;AAAA,EAE7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAkC;AAChC,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,MACd,MAAM,KAAK;AAAA,MACX,SAAS,KAAK;AAAA,MACd,WAAW,KAAK,UAAU,YAAA;AAAA,MAC1B,OAAO,KAAK;AAAA,IAAA;AAAA,EAEhB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,WAAmB;AACjB,UAAME,IAAa,KAAK,UAAU,eAAe,KAAK,UAAU,KAAK,OAAO,CAAC,KAAK;AAClF,WAAO,GAAG,KAAK,IAAI,KAAK,KAAK,IAAI,MAAM,KAAK,OAAO,GAAGA,CAAU;AAAA,EAClE;AACF;"}